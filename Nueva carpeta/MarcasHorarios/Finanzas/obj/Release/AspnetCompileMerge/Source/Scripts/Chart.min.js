/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 2.7.1
 *
 * Copyright 2017 Chart.js Contributors
 * Released under the MIT license
 * https://github.com/chartjs/Chart.js/blob/master/LICENSE.md
 */
!function (t) { if ("object" == typeof exports && "undefined" != typeof module) module.exports = t(); else if ("function" == typeof define && define.amd) define([], t); else { ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).Chart = t() } }(function () { return function t(e, i, n) { function a(r, s) { if (!i[r]) { if (!e[r]) { var l = "function" == typeof require && require; if (!s && l) return l(r, !0); if (o) return o(r, !0); var h = new Error("Cannot find module '" + r + "'"); throw h.code = "MODULE_NOT_FOUND", h } var u = i[r] = { exports: {} }; e[r][0].call(u.exports, function (t) { var i = e[r][1][t]; return a(i || t) }, u, u.exports, t, e, i, n) } return i[r].exports } for (var o = "function" == typeof require && require, r = 0; r < n.length; r++)a(n[r]); return a }({ 1: [function (t, e, i) { }, {}], 2: [function (t, e, i) { var n = t(6); e.exports = { getRgba: a, getHsla: o, getRgb: function (t) { var e = a(t); return e && e.slice(0, 3) }, getHsl: function (t) { var e = o(t); return e && e.slice(0, 3) }, getHwb: r, getAlpha: function (t) { var e = a(t); { if (e) return e[3]; if (e = o(t)) return e[3]; if (e = r(t)) return e[3] } }, hexString: function (t) { return "#" + d(t[0]) + d(t[1]) + d(t[2]) }, rgbString: function (t, e) { if (e < 1 || t[3] && t[3] < 1) return s(t, e); return "rgb(" + t[0] + ", " + t[1] + ", " + t[2] + ")" }, rgbaString: s, percentString: function (t, e) { if (e < 1 || t[3] && t[3] < 1) return l(t, e); var i = Math.round(t[0] / 255 * 100), n = Math.round(t[1] / 255 * 100), a = Math.round(t[2] / 255 * 100); return "rgb(" + i + "%, " + n + "%, " + a + "%)" }, percentaString: l, hslString: function (t, e) { if (e < 1 || t[3] && t[3] < 1) return h(t, e); return "hsl(" + t[0] + ", " + t[1] + "%, " + t[2] + "%)" }, hslaString: h, hwbString: function (t, e) { void 0 === e && (e = void 0 !== t[3] ? t[3] : 1); return "hwb(" + t[0] + ", " + t[1] + "%, " + t[2] + "%" + (void 0 !== e && 1 !== e ? ", " + e : "") + ")" }, keyword: function (t) { return c[t.slice(0, 3)] } }; function a(t) { if (t) { var e = [0, 0, 0], i = 1, a = t.match(/^#([a-fA-F0-9]{3})$/i); if (a) { a = a[1]; for (var o = 0; o < e.length; o++)e[o] = parseInt(a[o] + a[o], 16) } else if (a = t.match(/^#([a-fA-F0-9]{6})$/i)) { a = a[1]; for (o = 0; o < e.length; o++)e[o] = parseInt(a.slice(2 * o, 2 * o + 2), 16) } else if (a = t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) { for (o = 0; o < e.length; o++)e[o] = parseInt(a[o + 1]); i = parseFloat(a[4]) } else if (a = t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) { for (o = 0; o < e.length; o++)e[o] = Math.round(2.55 * parseFloat(a[o + 1])); i = parseFloat(a[4]) } else if (a = t.match(/(\w+)/)) { if ("transparent" == a[1]) return [0, 0, 0, 0]; if (!(e = n[a[1]])) return } for (o = 0; o < e.length; o++)e[o] = u(e[o], 0, 255); return i = i || 0 == i ? u(i, 0, 1) : 1, e[3] = i, e } } function o(t) { if (t) { var e = t.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/); if (e) { var i = parseFloat(e[4]); return [u(parseInt(e[1]), 0, 360), u(parseFloat(e[2]), 0, 100), u(parseFloat(e[3]), 0, 100), u(isNaN(i) ? 1 : i, 0, 1)] } } } function r(t) { if (t) { var e = t.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/); if (e) { var i = parseFloat(e[4]); return [u(parseInt(e[1]), 0, 360), u(parseFloat(e[2]), 0, 100), u(parseFloat(e[3]), 0, 100), u(isNaN(i) ? 1 : i, 0, 1)] } } } function s(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "rgba(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + e + ")" } function l(t, e) { return "rgba(" + Math.round(t[0] / 255 * 100) + "%, " + Math.round(t[1] / 255 * 100) + "%, " + Math.round(t[2] / 255 * 100) + "%, " + (e || t[3] || 1) + ")" } function h(t, e) { return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "hsla(" + t[0] + ", " + t[1] + "%, " + t[2] + "%, " + e + ")" } function u(t, e, i) { return Math.min(Math.max(e, t), i) } function d(t) { var e = t.toString(16).toUpperCase(); return e.length < 2 ? "0" + e : e } var c = {}; for (var f in n) c[n[f]] = f }, { 6: 6 }], 3: [function (t, e, i) { var n = t(5), a = t(2), o = function (t) { if (t instanceof o) return t; if (!(this instanceof o)) return new o(t); this.valid = !1, this.values = { rgb: [0, 0, 0], hsl: [0, 0, 0], hsv: [0, 0, 0], hwb: [0, 0, 0], cmyk: [0, 0, 0, 0], alpha: 1 }; var e; "string" == typeof t ? (e = a.getRgba(t)) ? this.setValues("rgb", e) : (e = a.getHsla(t)) ? this.setValues("hsl", e) : (e = a.getHwb(t)) && this.setValues("hwb", e) : "object" == typeof t && (void 0 !== (e = t).r || void 0 !== e.red ? this.setValues("rgb", e) : void 0 !== e.l || void 0 !== e.lightness ? this.setValues("hsl", e) : void 0 !== e.v || void 0 !== e.value ? this.setValues("hsv", e) : void 0 !== e.w || void 0 !== e.whiteness ? this.setValues("hwb", e) : void 0 === e.c && void 0 === e.cyan || this.setValues("cmyk", e)) }; o.prototype = { isValid: function () { return this.valid }, rgb: function () { return this.setSpace("rgb", arguments) }, hsl: function () { return this.setSpace("hsl", arguments) }, hsv: function () { return this.setSpace("hsv", arguments) }, hwb: function () { return this.setSpace("hwb", arguments) }, cmyk: function () { return this.setSpace("cmyk", arguments) }, rgbArray: function () { return this.values.rgb }, hslArray: function () { return this.values.hsl }, hsvArray: function () { return this.values.hsv }, hwbArray: function () { var t = this.values; return 1 !== t.alpha ? t.hwb.concat([t.alpha]) : t.hwb }, cmykArray: function () { return this.values.cmyk }, rgbaArray: function () { var t = this.values; return t.rgb.concat([t.alpha]) }, hslaArray: function () { var t = this.values; return t.hsl.concat([t.alpha]) }, alpha: function (t) { return void 0 === t ? this.values.alpha : (this.setValues("alpha", t), this) }, red: function (t) { return this.setChannel("rgb", 0, t) }, green: function (t) { return this.setChannel("rgb", 1, t) }, blue: function (t) { return this.setChannel("rgb", 2, t) }, hue: function (t) { return t && (t = (t %= 360) < 0 ? 360 + t : t), this.setChannel("hsl", 0, t) }, saturation: function (t) { return this.setChannel("hsl", 1, t) }, lightness: function (t) { return this.setChannel("hsl", 2, t) }, saturationv: function (t) { return this.setChannel("hsv", 1, t) }, whiteness: function (t) { return this.setChannel("hwb", 1, t) }, blackness: function (t) { return this.setChannel("hwb", 2, t) }, value: function (t) { return this.setChannel("hsv", 2, t) }, cyan: function (t) { return this.setChannel("cmyk", 0, t) }, magenta: function (t) { return this.setChannel("cmyk", 1, t) }, yellow: function (t) { return this.setChannel("cmyk", 2, t) }, black: function (t) { return this.setChannel("cmyk", 3, t) }, hexString: function () { return a.hexString(this.values.rgb) }, rgbString: function () { return a.rgbString(this.values.rgb, this.values.alpha) }, rgbaString: function () { return a.rgbaString(this.values.rgb, this.values.alpha) }, percentString: function () { return a.percentString(this.values.rgb, this.values.alpha) }, hslString: function () { return a.hslString(this.values.hsl, this.values.alpha) }, hslaString: function () { return a.hslaString(this.values.hsl, this.values.alpha) }, hwbString: function () { return a.hwbString(this.values.hwb, this.values.alpha) }, keyword: function () { return a.keyword(this.values.rgb, this.values.alpha) }, rgbNumber: function () { var t = this.values.rgb; return t[0] << 16 | t[1] << 8 | t[2] }, luminosity: function () { for (var t = this.values.rgb, e = [], i = 0; i < t.length; i++) { var n = t[i] / 255; e[i] = n <= .03928 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4) } return .2126 * e[0] + .7152 * e[1] + .0722 * e[2] }, contrast: function (t) { var e = this.luminosity(), i = t.luminosity(); return e > i ? (e + .05) / (i + .05) : (i + .05) / (e + .05) }, level: function (t) { var e = this.contrast(t); return e >= 7.1 ? "AAA" : e >= 4.5 ? "AA" : "" }, dark: function () { var t = this.values.rgb; return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3 < 128 }, light: function () { return !this.dark() }, negate: function () { for (var t = [], e = 0; e < 3; e++)t[e] = 255 - this.values.rgb[e]; return this.setValues("rgb", t), this }, lighten: function (t) { var e = this.values.hsl; return e[2] += e[2] * t, this.setValues("hsl", e), this }, darken: function (t) { var e = this.values.hsl; return e[2] -= e[2] * t, this.setValues("hsl", e), this }, saturate: function (t) { var e = this.values.hsl; return e[1] += e[1] * t, this.setValues("hsl", e), this }, desaturate: function (t) { var e = this.values.hsl; return e[1] -= e[1] * t, this.setValues("hsl", e), this }, whiten: function (t) { var e = this.values.hwb; return e[1] += e[1] * t, this.setValues("hwb", e), this }, blacken: function (t) { var e = this.values.hwb; return e[2] += e[2] * t, this.setValues("hwb", e), this }, greyscale: function () { var t = this.values.rgb, e = .3 * t[0] + .59 * t[1] + .11 * t[2]; return this.setValues("rgb", [e, e, e]), this }, clearer: function (t) { var e = this.values.alpha; return this.setValues("alpha", e - e * t), this }, opaquer: function (t) { var e = this.values.alpha; return this.setValues("alpha", e + e * t), this }, rotate: function (t) { var e = this.values.hsl, i = (e[0] + t) % 360; return e[0] = i < 0 ? 360 + i : i, this.setValues("hsl", e), this }, mix: function (t, e) { var i = t, n = void 0 === e ? .5 : e, a = 2 * n - 1, o = this.alpha() - i.alpha(), r = ((a * o == -1 ? a : (a + o) / (1 + a * o)) + 1) / 2, s = 1 - r; return this.rgb(r * this.red() + s * i.red(), r * this.green() + s * i.green(), r * this.blue() + s * i.blue()).alpha(this.alpha() * n + i.alpha() * (1 - n)) }, toJSON: function () { return this.rgb() }, clone: function () { var t, e, i = new o, n = this.values, a = i.values; for (var r in n) n.hasOwnProperty(r) && (t = n[r], "[object Array]" === (e = {}.toString.call(t)) ? a[r] = t.slice(0) : "[object Number]" === e ? a[r] = t : console.error("unexpected color value:", t)); return i } }, o.prototype.spaces = { rgb: ["red", "green", "blue"], hsl: ["hue", "saturation", "lightness"], hsv: ["hue", "saturation", "value"], hwb: ["hue", "whiteness", "blackness"], cmyk: ["cyan", "magenta", "yellow", "black"] }, o.prototype.maxes = { rgb: [255, 255, 255], hsl: [360, 100, 100], hsv: [360, 100, 100], hwb: [360, 100, 100], cmyk: [100, 100, 100, 100] }, o.prototype.getValues = function (t) { for (var e = this.values, i = {}, n = 0; n < t.length; n++)i[t.charAt(n)] = e[t][n]; return 1 !== e.alpha && (i.a = e.alpha), i }, o.prototype.setValues = function (t, e) { var i, a = this.values, o = this.spaces, r = this.maxes, s = 1; if (this.valid = !0, "alpha" === t) s = e; else if (e.length) a[t] = e.slice(0, t.length), s = e[t.length]; else if (void 0 !== e[t.charAt(0)]) { for (i = 0; i < t.length; i++)a[t][i] = e[t.charAt(i)]; s = e.a } else if (void 0 !== e[o[t][0]]) { var l = o[t]; for (i = 0; i < t.length; i++)a[t][i] = e[l[i]]; s = e.alpha } if (a.alpha = Math.max(0, Math.min(1, void 0 === s ? a.alpha : s)), "alpha" === t) return !1; var h; for (i = 0; i < t.length; i++)h = Math.max(0, Math.min(r[t][i], a[t][i])), a[t][i] = Math.round(h); for (var u in o) u !== t && (a[u] = n[t][u](a[t])); return !0 }, o.prototype.setSpace = function (t, e) { var i = e[0]; return void 0 === i ? this.getValues(t) : ("number" == typeof i && (i = Array.prototype.slice.call(e)), this.setValues(t, i), this) }, o.prototype.setChannel = function (t, e, i) { var n = this.values[t]; return void 0 === i ? n[e] : i === n[e] ? this : (n[e] = i, this.setValues(t, n), this) }, "undefined" != typeof window && (window.Color = o), e.exports = o }, { 2: 2, 5: 5 }], 4: [function (t, e, i) { e.exports = { rgb2hsl: n, rgb2hsv: a, rgb2hwb: o, rgb2cmyk: s, rgb2keyword: l, rgb2xyz: h, rgb2lab: u, rgb2lch: function (t) { return y(u(t)) }, hsl2rgb: d, hsl2hsv: function (t) { var e = t[0], i = t[1] / 100, n = t[2] / 100; if (0 === n) return [0, 0, 0]; return [e, 100 * (2 * (i *= (n *= 2) <= 1 ? n : 2 - n) / (n + i)), 100 * ((n + i) / 2)] }, hsl2hwb: function (t) { return o(d(t)) }, hsl2cmyk: function (t) { return s(d(t)) }, hsl2keyword: function (t) { return l(d(t)) }, hsv2rgb: c, hsv2hsl: function (t) { var e, i, n = t[0], a = t[1] / 100, o = t[2] / 100; return e = a * o, [n, 100 * (e = (e /= (i = (2 - a) * o) <= 1 ? i : 2 - i) || 0), 100 * (i /= 2)] }, hsv2hwb: function (t) { return o(c(t)) }, hsv2cmyk: function (t) { return s(c(t)) }, hsv2keyword: function (t) { return l(c(t)) }, hwb2rgb: f, hwb2hsl: function (t) { return n(f(t)) }, hwb2hsv: function (t) { return a(f(t)) }, hwb2cmyk: function (t) { return s(f(t)) }, hwb2keyword: function (t) { return l(f(t)) }, cmyk2rgb: p, cmyk2hsl: function (t) { return n(p(t)) }, cmyk2hsv: function (t) { return a(p(t)) }, cmyk2hwb: function (t) { return o(p(t)) }, cmyk2keyword: function (t) { return l(p(t)) }, keyword2rgb: M, keyword2hsl: function (t) { return n(M(t)) }, keyword2hsv: function (t) { return a(M(t)) }, keyword2hwb: function (t) { return o(M(t)) }, keyword2cmyk: function (t) { return s(M(t)) }, keyword2lab: function (t) { return u(M(t)) }, keyword2xyz: function (t) { return h(M(t)) }, xyz2rgb: v, xyz2lab: m, xyz2lch: function (t) { return y(m(t)) }, lab2xyz: x, lab2rgb: k, lab2lch: y, lch2lab: w, lch2xyz: function (t) { return x(w(t)) }, lch2rgb: function (t) { return k(w(t)) } }; function n(t) { var e, i, n = t[0] / 255, a = t[1] / 255, o = t[2] / 255, r = Math.min(n, a, o), s = Math.max(n, a, o), l = s - r; return s == r ? e = 0 : n == s ? e = (a - o) / l : a == s ? e = 2 + (o - n) / l : o == s && (e = 4 + (n - a) / l), (e = Math.min(60 * e, 360)) < 0 && (e += 360), i = (r + s) / 2, [e, 100 * (s == r ? 0 : i <= .5 ? l / (s + r) : l / (2 - s - r)), 100 * i] } function a(t) { var e, i, n = t[0], a = t[1], o = t[2], r = Math.min(n, a, o), s = Math.max(n, a, o), l = s - r; return i = 0 == s ? 0 : l / s * 1e3 / 10, s == r ? e = 0 : n == s ? e = (a - o) / l : a == s ? e = 2 + (o - n) / l : o == s && (e = 4 + (n - a) / l), (e = Math.min(60 * e, 360)) < 0 && (e += 360), [e, i, s / 255 * 1e3 / 10] } function o(t) { var e = t[0], i = t[1], a = t[2]; return [n(t)[0], 100 * (1 / 255 * Math.min(e, Math.min(i, a))), 100 * (a = 1 - 1 / 255 * Math.max(e, Math.max(i, a)))] } function s(t) { var e, i = t[0] / 255, n = t[1] / 255, a = t[2] / 255; return [100 * ((1 - i - (e = Math.min(1 - i, 1 - n, 1 - a))) / (1 - e) || 0), 100 * ((1 - n - e) / (1 - e) || 0), 100 * ((1 - a - e) / (1 - e) || 0), 100 * e] } function l(t) { return C[JSON.stringify(t)] } function h(t) { var e = t[0] / 255, i = t[1] / 255, n = t[2] / 255; return [100 * (.4124 * (e = e > .04045 ? Math.pow((e + .055) / 1.055, 2.4) : e / 12.92) + .3576 * (i = i > .04045 ? Math.pow((i + .055) / 1.055, 2.4) : i / 12.92) + .1805 * (n = n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92)), 100 * (.2126 * e + .7152 * i + .0722 * n), 100 * (.0193 * e + .1192 * i + .9505 * n)] } function u(t) { var e = h(t), i = e[0], n = e[1], a = e[2]; return n /= 100, a /= 108.883, i = (i /= 95.047) > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, [116 * (n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) - 16, 500 * (i - n), 200 * (n - (a = a > .008856 ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116))] } function d(t) { var e, i, n, a, o, r = t[0] / 360, s = t[1] / 100, l = t[2] / 100; if (0 == s) return [o = 255 * l, o, o]; e = 2 * l - (i = l < .5 ? l * (1 + s) : l + s - l * s), a = [0, 0, 0]; for (var h = 0; h < 3; h++)(n = r + 1 / 3 * -(h - 1)) < 0 && n++ , n > 1 && n-- , o = 6 * n < 1 ? e + 6 * (i - e) * n : 2 * n < 1 ? i : 3 * n < 2 ? e + (i - e) * (2 / 3 - n) * 6 : e, a[h] = 255 * o; return a } function c(t) { var e = t[0] / 60, i = t[1] / 100, n = t[2] / 100, a = Math.floor(e) % 6, o = e - Math.floor(e), r = 255 * n * (1 - i), s = 255 * n * (1 - i * o), l = 255 * n * (1 - i * (1 - o)); n *= 255; switch (a) { case 0: return [n, l, r]; case 1: return [s, n, r]; case 2: return [r, n, l]; case 3: return [r, s, n]; case 4: return [l, r, n]; case 5: return [n, r, s] } } function f(t) { var e, i, n, a, o = t[0] / 360, s = t[1] / 100, l = t[2] / 100, h = s + l; switch (h > 1 && (s /= h, l /= h), i = 1 - l, n = 6 * o - (e = Math.floor(6 * o)), 0 != (1 & e) && (n = 1 - n), a = s + n * (i - s), e) { default: case 6: case 0: r = i, g = a, b = s; break; case 1: r = a, g = i, b = s; break; case 2: r = s, g = i, b = a; break; case 3: r = s, g = a, b = i; break; case 4: r = a, g = s, b = i; break; case 5: r = i, g = s, b = a }return [255 * r, 255 * g, 255 * b] } function p(t) { var e = t[0] / 100, i = t[1] / 100, n = t[2] / 100, a = t[3] / 100; return [255 * (1 - Math.min(1, e * (1 - a) + a)), 255 * (1 - Math.min(1, i * (1 - a) + a)), 255 * (1 - Math.min(1, n * (1 - a) + a))] } function v(t) { var e, i, n, a = t[0] / 100, o = t[1] / 100, r = t[2] / 100; return i = -.9689 * a + 1.8758 * o + .0415 * r, n = .0557 * a + -.204 * o + 1.057 * r, e = (e = 3.2406 * a + -1.5372 * o + -.4986 * r) > .0031308 ? 1.055 * Math.pow(e, 1 / 2.4) - .055 : e *= 12.92, i = i > .0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - .055 : i *= 12.92, n = n > .0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : n *= 12.92, [255 * (e = Math.min(Math.max(0, e), 1)), 255 * (i = Math.min(Math.max(0, i), 1)), 255 * (n = Math.min(Math.max(0, n), 1))] } function m(t) { var e = t[0], i = t[1], n = t[2]; return i /= 100, n /= 108.883, e = (e /= 95.047) > .008856 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, [116 * (i = i > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116) - 16, 500 * (e - i), 200 * (i - (n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116))] } function x(t) { var e, i, n, a, o = t[0], r = t[1], s = t[2]; return o <= 8 ? a = (i = 100 * o / 903.3) / 100 * 7.787 + 16 / 116 : (i = 100 * Math.pow((o + 16) / 116, 3), a = Math.pow(i / 100, 1 / 3)), [e = e / 95.047 <= .008856 ? e = 95.047 * (r / 500 + a - 16 / 116) / 7.787 : 95.047 * Math.pow(r / 500 + a, 3), i, n = n / 108.883 <= .008859 ? n = 108.883 * (a - s / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(a - s / 200, 3)] } function y(t) { var e, i = t[0], n = t[1], a = t[2]; return (e = 360 * Math.atan2(a, n) / 2 / Math.PI) < 0 && (e += 360), [i, Math.sqrt(n * n + a * a), e] } function k(t) { return v(x(t)) } function w(t) { var e, i = t[0], n = t[1]; return e = t[2] / 360 * 2 * Math.PI, [i, n * Math.cos(e), n * Math.sin(e)] } function M(t) { return S[t] } var S = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, C = {}; for (var _ in S) C[JSON.stringify(S[_])] = _ }, {}], 5: [function (t, e, i) { var n = t(4), a = function () { return new h }; for (var o in n) { a[o + "Raw"] = function (t) { return function (e) { return "number" == typeof e && (e = Array.prototype.slice.call(arguments)), n[t](e) } }(o); var r = /(\w+)2(\w+)/.exec(o), s = r[1], l = r[2]; (a[s] = a[s] || {})[l] = a[o] = function (t) { return function (e) { "number" == typeof e && (e = Array.prototype.slice.call(arguments)); var i = n[t](e); if ("string" == typeof i || void 0 === i) return i; for (var a = 0; a < i.length; a++)i[a] = Math.round(i[a]); return i } }(o) } var h = function () { this.convs = {} }; h.prototype.routeSpace = function (t, e) { var i = e[0]; return void 0 === i ? this.getValues(t) : ("number" == typeof i && (i = Array.prototype.slice.call(e)), this.setValues(t, i)) }, h.prototype.setValues = function (t, e) { return this.space = t, this.convs = {}, this.convs[t] = e, this }, h.prototype.getValues = function (t) { var e = this.convs[t]; if (!e) { var i = this.space, n = this.convs[i]; e = a[i][t](n), this.convs[t] = e } return e }, ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (t) { h.prototype[t] = function (e) { return this.routeSpace(t, arguments) } }), e.exports = a }, { 4: 4 }], 6: [function (t, e, i) { "use strict"; e.exports = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] } }, {}], 7: [function (t, e, i) { var n = t(29)(); n.helpers = t(45), t(27)(n), n.defaults = t(25), n.Element = t(26), n.elements = t(40), n.Interaction = t(28), n.platform = t(48), t(31)(n), t(22)(n), t(23)(n), t(24)(n), t(30)(n), t(33)(n), t(32)(n), t(35)(n), t(54)(n), t(52)(n), t(53)(n), t(55)(n), t(56)(n), t(57)(n), t(15)(n), t(16)(n), t(17)(n), t(18)(n), t(19)(n), t(20)(n), t(21)(n), t(8)(n), t(9)(n), t(10)(n), t(11)(n), t(12)(n), t(13)(n), t(14)(n); var a = []; a.push(t(49)(n), t(50)(n), t(51)(n)), n.plugins.register(a), n.platform.initialize(), e.exports = n, "undefined" != typeof window && (window.Chart = n), n.canvasHelpers = n.helpers.canvas }, { 10: 10, 11: 11, 12: 12, 13: 13, 14: 14, 15: 15, 16: 16, 17: 17, 18: 18, 19: 19, 20: 20, 21: 21, 22: 22, 23: 23, 24: 24, 25: 25, 26: 26, 27: 27, 28: 28, 29: 29, 30: 30, 31: 31, 32: 32, 33: 33, 35: 35, 40: 40, 45: 45, 48: 48, 49: 49, 50: 50, 51: 51, 52: 52, 53: 53, 54: 54, 55: 55, 56: 56, 57: 57, 8: 8, 9: 9 }], 8: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Bar = function (e, i) { return i.type = "bar", new t(e, i) } } }, {}], 9: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Bubble = function (e, i) { return i.type = "bubble", new t(e, i) } } }, {}], 10: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Doughnut = function (e, i) { return i.type = "doughnut", new t(e, i) } } }, {}], 11: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Line = function (e, i) { return i.type = "line", new t(e, i) } } }, {}], 12: [function (t, e, i) { "use strict"; e.exports = function (t) { t.PolarArea = function (e, i) { return i.type = "polarArea", new t(e, i) } } }, {}], 13: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Radar = function (e, i) { return i.type = "radar", new t(e, i) } } }, {}], 14: [function (t, e, i) { "use strict"; e.exports = function (t) { t.Scatter = function (e, i) { return i.type = "scatter", new t(e, i) } } }, {}], 15: [function (t, e, i) { "use strict"; var n = t(25), a = t(40), o = t(45); n._set("bar", { hover: { mode: "label" }, scales: { xAxes: [{ type: "category", categoryPercentage: .8, barPercentage: .9, offset: !0, gridLines: { offsetGridLines: !0 } }], yAxes: [{ type: "linear" }] } }), n._set("horizontalBar", { hover: { mode: "index", axis: "y" }, scales: { xAxes: [{ type: "linear", position: "bottom" }], yAxes: [{ position: "left", type: "category", categoryPercentage: .8, barPercentage: .9, offset: !0, gridLines: { offsetGridLines: !0 } }] }, elements: { rectangle: { borderSkipped: "left" } }, tooltips: { callbacks: { title: function (t, e) { var i = ""; return t.length > 0 && (t[0].yLabel ? i = t[0].yLabel : e.labels.length > 0 && t[0].index < e.labels.length && (i = e.labels[t[0].index])), i }, label: function (t, e) { return (e.datasets[t.datasetIndex].label || "") + ": " + t.xLabel } }, mode: "index", axis: "y" } }); e.exports = function (t) { t.controllers.bar = t.DatasetController.extend({ dataElementType: a.Rectangle, initialize: function () { var e; t.DatasetController.prototype.initialize.apply(this, arguments), (e = this.getMeta()).stack = this.getDataset().stack, e.bar = !0 }, update: function (t) { var e, i, n = this.getMeta().data; for (this._ruler = this.getRuler(), e = 0, i = n.length; e < i; ++e)this.updateElement(n[e], e, t) }, updateElement: function (t, e, i) { var n = this.chart, a = this.getMeta(), r = this.getDataset(), s = t.custom || {}, l = n.options.elements.rectangle; t._xScale = this.getScaleForId(a.xAxisID), t._yScale = this.getScaleForId(a.yAxisID), t._datasetIndex = this.index, t._index = e, t._model = { datasetLabel: r.label, label: n.data.labels[e], borderSkipped: s.borderSkipped ? s.borderSkipped : l.borderSkipped, backgroundColor: s.backgroundColor ? s.backgroundColor : o.valueAtIndexOrDefault(r.backgroundColor, e, l.backgroundColor), borderColor: s.borderColor ? s.borderColor : o.valueAtIndexOrDefault(r.borderColor, e, l.borderColor), borderWidth: s.borderWidth ? s.borderWidth : o.valueAtIndexOrDefault(r.borderWidth, e, l.borderWidth) }, this.updateElementGeometry(t, e, i), t.pivot() }, updateElementGeometry: function (t, e, i) { var n = t._model, a = this.getValueScale(), o = a.getBasePixel(), r = a.isHorizontal(), s = this._ruler || this.getRuler(), l = this.calculateBarValuePixels(this.index, e), h = this.calculateBarIndexPixels(this.index, e, s); n.horizontal = r, n.base = i ? o : l.base, n.x = r ? i ? o : l.head : h.center, n.y = r ? h.center : i ? o : l.head, n.height = r ? h.size : void 0, n.width = r ? void 0 : h.size }, getValueScaleId: function () { return this.getMeta().yAxisID }, getIndexScaleId: function () { return this.getMeta().xAxisID }, getValueScale: function () { return this.getScaleForId(this.getValueScaleId()) }, getIndexScale: function () { return this.getScaleForId(this.getIndexScaleId()) }, _getStacks: function (t) { var e, i, n = this.chart, a = this.getIndexScale().options.stacked, o = void 0 === t ? n.data.datasets.length : t + 1, r = []; for (e = 0; e < o; ++e)(i = n.getDatasetMeta(e)).bar && n.isDatasetVisible(e) && (!1 === a || !0 === a && -1 === r.indexOf(i.stack) || void 0 === a && (void 0 === i.stack || -1 === r.indexOf(i.stack))) && r.push(i.stack); return r }, getStackCount: function () { return this._getStacks().length }, getStackIndex: function (t, e) { var i = this._getStacks(t), n = void 0 !== e ? i.indexOf(e) : -1; return -1 === n ? i.length - 1 : n }, getRuler: function () { var t, e, i = this.getIndexScale(), n = this.getStackCount(), a = this.index, r = i.isHorizontal(), s = r ? i.left : i.top, l = s + (r ? i.width : i.height), h = []; for (t = 0, e = this.getMeta().data.length; t < e; ++t)h.push(i.getPixelForValue(null, t, a)); return { min: o.isNullOrUndef(i.options.barThickness) ? function (t, e) { var i, n, a, o, r = t.isHorizontal() ? t.width : t.height, s = t.getTicks(); for (a = 1, o = e.length; a < o; ++a)r = Math.min(r, e[a] - e[a - 1]); for (a = 0, o = s.length; a < o; ++a)n = t.getPixelForTick(a), r = a > 0 ? Math.min(r, n - i) : r, i = n; return r }(i, h) : -1, pixels: h, start: s, end: l, stackCount: n, scale: i } }, calculateBarValuePixels: function (t, e) { var i, n, a, o, r, s, l = this.chart, h = this.getMeta(), u = this.getValueScale(), d = l.data.datasets, c = u.getRightValue(d[t].data[e]), f = u.options.stacked, g = h.stack, p = 0; if (f || void 0 === f && void 0 !== g) for (i = 0; i < t; ++i)(n = l.getDatasetMeta(i)).bar && n.stack === g && n.controller.getValueScaleId() === u.id && l.isDatasetVisible(i) && (a = u.getRightValue(d[i].data[e]), (c < 0 && a < 0 || c >= 0 && a > 0) && (p += a)); return o = u.getPixelForValue(p), { size: s = ((r = u.getPixelForValue(p + c)) - o) / 2, base: o, head: r, center: r + s / 2 } }, calculateBarIndexPixels: function (t, e, i) { var n = i.scale.options, a = "flex" === n.barThickness ? function (t, e, i) { var n, a = e.pixels, o = a[t], r = t > 0 ? a[t - 1] : null, s = t < a.length - 1 ? a[t + 1] : null, l = i.categoryPercentage; return null === r && (r = o - (null === s ? e.end - o : s - o)), null === s && (s = o + o - r), n = o - (o - r) / 2 * l, { chunk: (s - r) / 2 * l / e.stackCount, ratio: i.barPercentage, start: n } }(e, i, n) : function (t, e, i) { var n, a, r = i.barThickness, s = e.stackCount, l = e.pixels[t]; return o.isNullOrUndef(r) ? (n = e.min * i.categoryPercentage, a = i.barPercentage) : (n = r * s, a = 1), { chunk: n / s, ratio: a, start: l - n / 2 } }(e, i, n), r = this.getStackIndex(t, this.getMeta().stack), s = a.start + a.chunk * r + a.chunk / 2, l = Math.min(o.valueOrDefault(n.maxBarThickness, 1 / 0), a.chunk * a.ratio); return { base: s - l / 2, head: s + l / 2, center: s, size: l } }, draw: function () { var t = this.chart, e = this.getValueScale(), i = this.getMeta().data, n = this.getDataset(), a = i.length, r = 0; for (o.canvas.clipArea(t.ctx, t.chartArea); r < a; ++r)isNaN(e.getRightValue(n.data[r])) || i[r].draw(); o.canvas.unclipArea(t.ctx) }, setHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t._index, n = t.custom || {}, a = t._model; a.backgroundColor = n.hoverBackgroundColor ? n.hoverBackgroundColor : o.valueAtIndexOrDefault(e.hoverBackgroundColor, i, o.getHoverColor(a.backgroundColor)), a.borderColor = n.hoverBorderColor ? n.hoverBorderColor : o.valueAtIndexOrDefault(e.hoverBorderColor, i, o.getHoverColor(a.borderColor)), a.borderWidth = n.hoverBorderWidth ? n.hoverBorderWidth : o.valueAtIndexOrDefault(e.hoverBorderWidth, i, a.borderWidth) }, removeHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t._index, n = t.custom || {}, a = t._model, r = this.chart.options.elements.rectangle; a.backgroundColor = n.backgroundColor ? n.backgroundColor : o.valueAtIndexOrDefault(e.backgroundColor, i, r.backgroundColor), a.borderColor = n.borderColor ? n.borderColor : o.valueAtIndexOrDefault(e.borderColor, i, r.borderColor), a.borderWidth = n.borderWidth ? n.borderWidth : o.valueAtIndexOrDefault(e.borderWidth, i, r.borderWidth) } }), t.controllers.horizontalBar = t.controllers.bar.extend({ getValueScaleId: function () { return this.getMeta().xAxisID }, getIndexScaleId: function () { return this.getMeta().yAxisID } }) } }, { 25: 25, 40: 40, 45: 45 }], 16: [function (t, e, i) { "use strict"; var n = t(25), a = t(40), o = t(45); n._set("bubble", { hover: { mode: "single" }, scales: { xAxes: [{ type: "linear", position: "bottom", id: "x-axis-0" }], yAxes: [{ type: "linear", position: "left", id: "y-axis-0" }] }, tooltips: { callbacks: { title: function () { return "" }, label: function (t, e) { var i = e.datasets[t.datasetIndex].label || "", n = e.datasets[t.datasetIndex].data[t.index]; return i + ": (" + t.xLabel + ", " + t.yLabel + ", " + n.r + ")" } } } }), e.exports = function (t) { t.controllers.bubble = t.DatasetController.extend({ dataElementType: a.Point, update: function (t) { var e = this, i = e.getMeta().data; o.each(i, function (i, n) { e.updateElement(i, n, t) }) }, updateElement: function (t, e, i) { var n = this.getMeta(), a = t.custom || {}, o = this.getScaleForId(n.xAxisID), r = this.getScaleForId(n.yAxisID), s = this._resolveElementOptions(t, e), l = this.getDataset().data[e], h = this.index, u = i ? o.getPixelForDecimal(.5) : o.getPixelForValue("object" == typeof l ? l : NaN, e, h), d = i ? r.getBasePixel() : r.getPixelForValue(l, e, h); t._xScale = o, t._yScale = r, t._options = s, t._datasetIndex = h, t._index = e, t._model = { backgroundColor: s.backgroundColor, borderColor: s.borderColor, borderWidth: s.borderWidth, hitRadius: s.hitRadius, pointStyle: s.pointStyle, radius: i ? 0 : s.radius, skip: a.skip || isNaN(u) || isNaN(d), x: u, y: d }, t.pivot() }, setHoverStyle: function (t) { var e = t._model, i = t._options; e.backgroundColor = o.valueOrDefault(i.hoverBackgroundColor, o.getHoverColor(i.backgroundColor)), e.borderColor = o.valueOrDefault(i.hoverBorderColor, o.getHoverColor(i.borderColor)), e.borderWidth = o.valueOrDefault(i.hoverBorderWidth, i.borderWidth), e.radius = i.radius + i.hoverRadius }, removeHoverStyle: function (t) { var e = t._model, i = t._options; e.backgroundColor = i.backgroundColor, e.borderColor = i.borderColor, e.borderWidth = i.borderWidth, e.radius = i.radius }, _resolveElementOptions: function (t, e) { var i, n, a, r = this.chart, s = r.data.datasets[this.index], l = t.custom || {}, h = r.options.elements.point, u = o.options.resolve, d = s.data[e], c = {}, f = { chart: r, dataIndex: e, dataset: s, datasetIndex: this.index }, g = ["backgroundColor", "borderColor", "borderWidth", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth", "hoverRadius", "hitRadius", "pointStyle"]; for (i = 0, n = g.length; i < n; ++i)c[a = g[i]] = u([l[a], s[a], h[a]], f, e); return c.radius = u([l.radius, d ? d.r : void 0, s.radius, h.radius], f, e), c } }) } }, { 25: 25, 40: 40, 45: 45 }], 17: [function (t, e, i) { "use strict"; var n = t(25), a = t(40), o = t(45); n._set("doughnut", { animation: { animateRotate: !0, animateScale: !1 }, hover: { mode: "single" }, legendCallback: function (t) { var e = []; e.push('<ul class="' + t.id + '-legend">'); var i = t.data, n = i.datasets, a = i.labels; if (n.length) for (var o = 0; o < n[0].data.length; ++o)e.push('<li><span style="background-color:' + n[0].backgroundColor[o] + '"></span>'), a[o] && e.push(a[o]), e.push("</li>"); return e.push("</ul>"), e.join("") }, legend: { labels: { generateLabels: function (t) { var e = t.data; return e.labels.length && e.datasets.length ? e.labels.map(function (i, n) { var a = t.getDatasetMeta(0), r = e.datasets[0], s = a.data[n], l = s && s.custom || {}, h = o.valueAtIndexOrDefault, u = t.options.elements.arc; return { text: i, fillStyle: l.backgroundColor ? l.backgroundColor : h(r.backgroundColor, n, u.backgroundColor), strokeStyle: l.borderColor ? l.borderColor : h(r.borderColor, n, u.borderColor), lineWidth: l.borderWidth ? l.borderWidth : h(r.borderWidth, n, u.borderWidth), hidden: isNaN(r.data[n]) || a.data[n].hidden, index: n } }) : [] } }, onClick: function (t, e) { var i, n, a, o = e.index, r = this.chart; for (i = 0, n = (r.data.datasets || []).length; i < n; ++i)(a = r.getDatasetMeta(i)).data[o] && (a.data[o].hidden = !a.data[o].hidden); r.update() } }, cutoutPercentage: 50, rotation: -.5 * Math.PI, circumference: 2 * Math.PI, tooltips: { callbacks: { title: function () { return "" }, label: function (t, e) { var i = e.labels[t.index], n = ": " + e.datasets[t.datasetIndex].data[t.index]; return o.isArray(i) ? (i = i.slice())[0] += n : i += n, i } } } }), n._set("pie", o.clone(n.doughnut)), n._set("pie", { cutoutPercentage: 0 }), e.exports = function (t) { t.controllers.doughnut = t.controllers.pie = t.DatasetController.extend({ dataElementType: a.Arc, linkScales: o.noop, getRingIndex: function (t) { for (var e = 0, i = 0; i < t; ++i)this.chart.isDatasetVisible(i) && ++e; return e }, update: function (t) { var e = this, i = e.chart, n = i.chartArea, a = i.options, r = a.elements.arc, s = n.right - n.left - r.borderWidth, l = n.bottom - n.top - r.borderWidth, h = Math.min(s, l), u = { x: 0, y: 0 }, d = e.getMeta(), c = a.cutoutPercentage, f = a.circumference; if (f < 2 * Math.PI) { var g = a.rotation % (2 * Math.PI), p = (g += 2 * Math.PI * (g >= Math.PI ? -1 : g < -Math.PI ? 1 : 0)) + f, v = Math.cos(g), m = Math.sin(g), b = Math.cos(p), x = Math.sin(p), y = g <= 0 && p >= 0 || g <= 2 * Math.PI && 2 * Math.PI <= p, k = g <= .5 * Math.PI && .5 * Math.PI <= p || g <= 2.5 * Math.PI && 2.5 * Math.PI <= p, w = g <= -Math.PI && -Math.PI <= p || g <= Math.PI && Math.PI <= p, M = g <= .5 * -Math.PI && .5 * -Math.PI <= p || g <= 1.5 * Math.PI && 1.5 * Math.PI <= p, S = c / 100, C = w ? -1 : Math.min(v * (v < 0 ? 1 : S), b * (b < 0 ? 1 : S)), _ = M ? -1 : Math.min(m * (m < 0 ? 1 : S), x * (x < 0 ? 1 : S)), D = y ? 1 : Math.max(v * (v > 0 ? 1 : S), b * (b > 0 ? 1 : S)), I = k ? 1 : Math.max(m * (m > 0 ? 1 : S), x * (x > 0 ? 1 : S)), P = .5 * (D - C), A = .5 * (I - _); h = Math.min(s / P, l / A), u = { x: -.5 * (D + C), y: -.5 * (I + _) } } i.borderWidth = e.getMaxBorderWidth(d.data), i.outerRadius = Math.max((h - i.borderWidth) / 2, 0), i.innerRadius = Math.max(c ? i.outerRadius / 100 * c : 0, 0), i.radiusLength = (i.outerRadius - i.innerRadius) / i.getVisibleDatasetCount(), i.offsetX = u.x * i.outerRadius, i.offsetY = u.y * i.outerRadius, d.total = e.calculateTotal(), e.outerRadius = i.outerRadius - i.radiusLength * e.getRingIndex(e.index), e.innerRadius = Math.max(e.outerRadius - i.radiusLength, 0), o.each(d.data, function (i, n) { e.updateElement(i, n, t) }) }, updateElement: function (t, e, i) { var n = this.chart, a = n.chartArea, r = n.options, s = r.animation, l = (a.left + a.right) / 2, h = (a.top + a.bottom) / 2, u = r.rotation, d = r.rotation, c = this.getDataset(), f = i && s.animateRotate ? 0 : t.hidden ? 0 : this.calculateCircumference(c.data[e]) * (r.circumference / (2 * Math.PI)), g = i && s.animateScale ? 0 : this.innerRadius, p = i && s.animateScale ? 0 : this.outerRadius, v = o.valueAtIndexOrDefault; o.extend(t, { _datasetIndex: this.index, _index: e, _model: { x: l + n.offsetX, y: h + n.offsetY, startAngle: u, endAngle: d, circumference: f, outerRadius: p, innerRadius: g, label: v(c.label, e, n.data.labels[e]) } }); var m = t._model; this.removeHoverStyle(t), i && s.animateRotate || (m.startAngle = 0 === e ? r.rotation : this.getMeta().data[e - 1]._model.endAngle, m.endAngle = m.startAngle + m.circumference), t.pivot() }, removeHoverStyle: function (e) { t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.arc) }, calculateTotal: function () { var t, e = this.getDataset(), i = this.getMeta(), n = 0; return o.each(i.data, function (i, a) { t = e.data[a], isNaN(t) || i.hidden || (n += Math.abs(t)) }), n }, calculateCircumference: function (t) { var e = this.getMeta().total; return e > 0 && !isNaN(t) ? 2 * Math.PI * (t / e) : 0 }, getMaxBorderWidth: function (t) { for (var e, i, n = 0, a = this.index, o = t.length, r = 0; r < o; r++)e = t[r]._model ? t[r]._model.borderWidth : 0, n = (i = t[r]._chart ? t[r]._chart.config.data.datasets[a].hoverBorderWidth : 0) > (n = e > n ? e : n) ? i : n; return n } }) } }, { 25: 25, 40: 40, 45: 45 }], 18: [function (t, e, i) { "use strict"; var n = t(25), a = t(40), o = t(45); n._set("line", { showLines: !0, spanGaps: !1, hover: { mode: "label" }, scales: { xAxes: [{ type: "category", id: "x-axis-0" }], yAxes: [{ type: "linear", id: "y-axis-0" }] } }), e.exports = function (t) { function e(t, e) { return o.valueOrDefault(t.showLine, e.showLines) } t.controllers.line = t.DatasetController.extend({ datasetElementType: a.Line, dataElementType: a.Point, update: function (t) { var i, n, a, r = this.getMeta(), s = r.dataset, l = r.data || [], h = this.chart.options, u = h.elements.line, d = this.getScaleForId(r.yAxisID), c = this.getDataset(), f = e(c, h); for (f && (a = s.custom || {}, void 0 !== c.tension && void 0 === c.lineTension && (c.lineTension = c.tension), s._scale = d, s._datasetIndex = this.index, s._children = l, s._model = { spanGaps: c.spanGaps ? c.spanGaps : h.spanGaps, tension: a.tension ? a.tension : o.valueOrDefault(c.lineTension, u.tension), backgroundColor: a.backgroundColor ? a.backgroundColor : c.backgroundColor || u.backgroundColor, borderWidth: a.borderWidth ? a.borderWidth : c.borderWidth || u.borderWidth, borderColor: a.borderColor ? a.borderColor : c.borderColor || u.borderColor, borderCapStyle: a.borderCapStyle ? a.borderCapStyle : c.borderCapStyle || u.borderCapStyle, borderDash: a.borderDash ? a.borderDash : c.borderDash || u.borderDash, borderDashOffset: a.borderDashOffset ? a.borderDashOffset : c.borderDashOffset || u.borderDashOffset, borderJoinStyle: a.borderJoinStyle ? a.borderJoinStyle : c.borderJoinStyle || u.borderJoinStyle, fill: a.fill ? a.fill : void 0 !== c.fill ? c.fill : u.fill, steppedLine: a.steppedLine ? a.steppedLine : o.valueOrDefault(c.steppedLine, u.stepped), cubicInterpolationMode: a.cubicInterpolationMode ? a.cubicInterpolationMode : o.valueOrDefault(c.cubicInterpolationMode, u.cubicInterpolationMode) }, s.pivot()), i = 0, n = l.length; i < n; ++i)this.updateElement(l[i], i, t); for (f && 0 !== s._model.tension && this.updateBezierControlPoints(), i = 0, n = l.length; i < n; ++i)l[i].pivot() }, getPointBackgroundColor: function (t, e) { var i = this.chart.options.elements.point.backgroundColor, n = this.getDataset(), a = t.custom || {}; return a.backgroundColor ? i = a.backgroundColor : n.pointBackgroundColor ? i = o.valueAtIndexOrDefault(n.pointBackgroundColor, e, i) : n.backgroundColor && (i = n.backgroundColor), i }, getPointBorderColor: function (t, e) { var i = this.chart.options.elements.point.borderColor, n = this.getDataset(), a = t.custom || {}; return a.borderColor ? i = a.borderColor : n.pointBorderColor ? i = o.valueAtIndexOrDefault(n.pointBorderColor, e, i) : n.borderColor && (i = n.borderColor), i }, getPointBorderWidth: function (t, e) { var i = this.chart.options.elements.point.borderWidth, n = this.getDataset(), a = t.custom || {}; return isNaN(a.borderWidth) ? !isNaN(n.pointBorderWidth) || o.isArray(n.pointBorderWidth) ? i = o.valueAtIndexOrDefault(n.pointBorderWidth, e, i) : isNaN(n.borderWidth) || (i = n.borderWidth) : i = a.borderWidth, i }, updateElement: function (t, e, i) { var n, a, r = this.getMeta(), s = t.custom || {}, l = this.getDataset(), h = this.index, u = l.data[e], d = this.getScaleForId(r.yAxisID), c = this.getScaleForId(r.xAxisID), f = this.chart.options.elements.point; void 0 !== l.radius && void 0 === l.pointRadius && (l.pointRadius = l.radius), void 0 !== l.hitRadius && void 0 === l.pointHitRadius && (l.pointHitRadius = l.hitRadius), n = c.getPixelForValue("object" == typeof u ? u : NaN, e, h), a = i ? d.getBasePixel() : this.calculatePointY(u, e, h), t._xScale = c, t._yScale = d, t._datasetIndex = h, t._index = e, t._model = { x: n, y: a, skip: s.skip || isNaN(n) || isNaN(a), radius: s.radius || o.valueAtIndexOrDefault(l.pointRadius, e, f.radius), pointStyle: s.pointStyle || o.valueAtIndexOrDefault(l.pointStyle, e, f.pointStyle), backgroundColor: this.getPointBackgroundColor(t, e), borderColor: this.getPointBorderColor(t, e), borderWidth: this.getPointBorderWidth(t, e), tension: r.dataset._model ? r.dataset._model.tension : 0, steppedLine: !!r.dataset._model && r.dataset._model.steppedLine, hitRadius: s.hitRadius || o.valueAtIndexOrDefault(l.pointHitRadius, e, f.hitRadius) } }, calculatePointY: function (t, e, i) { var n, a, o, r = this.chart, s = this.getMeta(), l = this.getScaleForId(s.yAxisID), h = 0, u = 0; if (l.options.stacked) { for (n = 0; n < i; n++)if (a = r.data.datasets[n], "line" === (o = r.getDatasetMeta(n)).type && o.yAxisID === l.id && r.isDatasetVisible(n)) { var d = Number(l.getRightValue(a.data[e])); d < 0 ? u += d || 0 : h += d || 0 } var c = Number(l.getRightValue(t)); return c < 0 ? l.getPixelForValue(u + c) : l.getPixelForValue(h + c) } return l.getPixelForValue(t) }, updateBezierControlPoints: function () { var t, e, i, n, a = this.getMeta(), r = this.chart.chartArea, s = a.data || []; a.dataset._model.spanGaps && (s = s.filter(function (t) { return !t._model.skip })); function l(t, e, i) { return Math.max(Math.min(t, i), e) } if ("monotone" === a.dataset._model.cubicInterpolationMode) o.splineCurveMonotone(s); else for (t = 0, e = s.length; t < e; ++t)i = s[t]._model, n = o.splineCurve(o.previousItem(s, t)._model, i, o.nextItem(s, t)._model, a.dataset._model.tension), i.controlPointPreviousX = n.previous.x, i.controlPointPreviousY = n.previous.y, i.controlPointNextX = n.next.x, i.controlPointNextY = n.next.y; if (this.chart.options.elements.line.capBezierPoints) for (t = 0, e = s.length; t < e; ++t)(i = s[t]._model).controlPointPreviousX = l(i.controlPointPreviousX, r.left, r.right), i.controlPointPreviousY = l(i.controlPointPreviousY, r.top, r.bottom), i.controlPointNextX = l(i.controlPointNextX, r.left, r.right), i.controlPointNextY = l(i.controlPointNextY, r.top, r.bottom) }, draw: function () { var t = this.chart, i = this.getMeta(), n = i.data || [], a = t.chartArea, r = n.length, s = 0; for (o.canvas.clipArea(t.ctx, a), e(this.getDataset(), t.options) && i.dataset.draw(), o.canvas.unclipArea(t.ctx); s < r; ++s)n[s].draw(a) }, setHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t._index, n = t.custom || {}, a = t._model; a.radius = n.hoverRadius || o.valueAtIndexOrDefault(e.pointHoverRadius, i, this.chart.options.elements.point.hoverRadius), a.backgroundColor = n.hoverBackgroundColor || o.valueAtIndexOrDefault(e.pointHoverBackgroundColor, i, o.getHoverColor(a.backgroundColor)), a.borderColor = n.hoverBorderColor || o.valueAtIndexOrDefault(e.pointHoverBorderColor, i, o.getHoverColor(a.borderColor)), a.borderWidth = n.hoverBorderWidth || o.valueAtIndexOrDefault(e.pointHoverBorderWidth, i, a.borderWidth) }, removeHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t._index, n = t.custom || {}, a = t._model; void 0 !== e.radius && void 0 === e.pointRadius && (e.pointRadius = e.radius), a.radius = n.radius || o.valueAtIndexOrDefault(e.pointRadius, i, this.chart.options.elements.point.radius), a.backgroundColor = this.getPointBackgroundColor(t, i), a.borderColor = this.getPointBorderColor(t, i), a.borderWidth = this.getPointBorderWidth(t, i) } }) } }, { 25: 25, 40: 40, 45: 45 }], 19: [function (t, e, i) { "use strict"; var n = t(25), a = t(40), o = t(45); n._set("polarArea", { scale: { type: "radialLinear", angleLines: { display: !1 }, gridLines: { circular: !0 }, pointLabels: { display: !1 }, ticks: { beginAtZero: !0 } }, animation: { animateRotate: !0, animateScale: !0 }, startAngle: -.5 * Math.PI, legendCallback: function (t) { var e = []; e.push('<ul class="' + t.id + '-legend">'); var i = t.data, n = i.datasets, a = i.labels; if (n.length) for (var o = 0; o < n[0].data.length; ++o)e.push('<li><span style="background-color:' + n[0].backgroundColor[o] + '"></span>'), a[o] && e.push(a[o]), e.push("</li>"); return e.push("</ul>"), e.join("") }, legend: { labels: { generateLabels: function (t) { var e = t.data; return e.labels.length && e.datasets.length ? e.labels.map(function (i, n) { var a = t.getDatasetMeta(0), r = e.datasets[0], s = a.data[n].custom || {}, l = o.valueAtIndexOrDefault, h = t.options.elements.arc; return { text: i, fillStyle: s.backgroundColor ? s.backgroundColor : l(r.backgroundColor, n, h.backgroundColor), strokeStyle: s.borderColor ? s.borderColor : l(r.borderColor, n, h.borderColor), lineWidth: s.borderWidth ? s.borderWidth : l(r.borderWidth, n, h.borderWidth), hidden: isNaN(r.data[n]) || a.data[n].hidden, index: n } }) : [] } }, onClick: function (t, e) { var i, n, a, o = e.index, r = this.chart; for (i = 0, n = (r.data.datasets || []).length; i < n; ++i)(a = r.getDatasetMeta(i)).data[o].hidden = !a.data[o].hidden; r.update() } }, tooltips: { callbacks: { title: function () { return "" }, label: function (t, e) { return e.labels[t.index] + ": " + t.yLabel } } } }), e.exports = function (t) { t.controllers.polarArea = t.DatasetController.extend({ dataElementType: a.Arc, linkScales: o.noop, update: function (t) { var e = this, i = e.chart, n = i.chartArea, a = e.getMeta(), r = i.options, s = r.elements.arc, l = Math.min(n.right - n.left, n.bottom - n.top); i.outerRadius = Math.max((l - s.borderWidth / 2) / 2, 0), i.innerRadius = Math.max(r.cutoutPercentage ? i.outerRadius / 100 * r.cutoutPercentage : 1, 0), i.radiusLength = (i.outerRadius - i.innerRadius) / i.getVisibleDatasetCount(), e.outerRadius = i.outerRadius - i.radiusLength * e.index, e.innerRadius = e.outerRadius - i.radiusLength, a.count = e.countVisibleElements(), o.each(a.data, function (i, n) { e.updateElement(i, n, t) }) }, updateElement: function (t, e, i) { for (var n = this.chart, a = this.getDataset(), r = n.options, s = r.animation, l = n.scale, h = n.data.labels, u = this.calculateCircumference(a.data[e]), d = l.xCenter, c = l.yCenter, f = 0, g = this.getMeta(), p = 0; p < e; ++p)isNaN(a.data[p]) || g.data[p].hidden || ++f; var v = r.startAngle, m = t.hidden ? 0 : l.getDistanceFromCenterForValue(a.data[e]), b = v + u * f, x = b + (t.hidden ? 0 : u), y = s.animateScale ? 0 : l.getDistanceFromCenterForValue(a.data[e]); o.extend(t, { _datasetIndex: this.index, _index: e, _scale: l, _model: { x: d, y: c, innerRadius: 0, outerRadius: i ? y : m, startAngle: i && s.animateRotate ? v : b, endAngle: i && s.animateRotate ? v : x, label: o.valueAtIndexOrDefault(h, e, h[e]) } }), this.removeHoverStyle(t), t.pivot() }, removeHoverStyle: function (e) { t.DatasetController.prototype.removeHoverStyle.call(this, e, this.chart.options.elements.arc) }, countVisibleElements: function () { var t = this.getDataset(), e = this.getMeta(), i = 0; return o.each(e.data, function (e, n) { isNaN(t.data[n]) || e.hidden || i++ }), i }, calculateCircumference: function (t) { var e = this.getMeta().count; return e > 0 && !isNaN(t) ? 2 * Math.PI / e : 0 } }) } }, { 25: 25, 40: 40, 45: 45 }], 20: [function (t, e, i) { "use strict"; var n = t(25), a = t(40), o = t(45); n._set("radar", { scale: { type: "radialLinear" }, elements: { line: { tension: 0 } } }), e.exports = function (t) { t.controllers.radar = t.DatasetController.extend({ datasetElementType: a.Line, dataElementType: a.Point, linkScales: o.noop, update: function (t) { var e = this, i = e.getMeta(), n = i.dataset, a = i.data, r = n.custom || {}, s = e.getDataset(), l = e.chart.options.elements.line, h = e.chart.scale; void 0 !== s.tension && void 0 === s.lineTension && (s.lineTension = s.tension), o.extend(i.dataset, { _datasetIndex: e.index, _scale: h, _children: a, _loop: !0, _model: { tension: r.tension ? r.tension : o.valueOrDefault(s.lineTension, l.tension), backgroundColor: r.backgroundColor ? r.backgroundColor : s.backgroundColor || l.backgroundColor, borderWidth: r.borderWidth ? r.borderWidth : s.borderWidth || l.borderWidth, borderColor: r.borderColor ? r.borderColor : s.borderColor || l.borderColor, fill: r.fill ? r.fill : void 0 !== s.fill ? s.fill : l.fill, borderCapStyle: r.borderCapStyle ? r.borderCapStyle : s.borderCapStyle || l.borderCapStyle, borderDash: r.borderDash ? r.borderDash : s.borderDash || l.borderDash, borderDashOffset: r.borderDashOffset ? r.borderDashOffset : s.borderDashOffset || l.borderDashOffset, borderJoinStyle: r.borderJoinStyle ? r.borderJoinStyle : s.borderJoinStyle || l.borderJoinStyle } }), i.dataset.pivot(), o.each(a, function (i, n) { e.updateElement(i, n, t) }, e), e.updateBezierControlPoints() }, updateElement: function (t, e, i) { var n = t.custom || {}, a = this.getDataset(), r = this.chart.scale, s = this.chart.options.elements.point, l = r.getPointPositionForValue(e, a.data[e]); void 0 !== a.radius && void 0 === a.pointRadius && (a.pointRadius = a.radius), void 0 !== a.hitRadius && void 0 === a.pointHitRadius && (a.pointHitRadius = a.hitRadius), o.extend(t, { _datasetIndex: this.index, _index: e, _scale: r, _model: { x: i ? r.xCenter : l.x, y: i ? r.yCenter : l.y, tension: n.tension ? n.tension : o.valueOrDefault(a.lineTension, this.chart.options.elements.line.tension), radius: n.radius ? n.radius : o.valueAtIndexOrDefault(a.pointRadius, e, s.radius), backgroundColor: n.backgroundColor ? n.backgroundColor : o.valueAtIndexOrDefault(a.pointBackgroundColor, e, s.backgroundColor), borderColor: n.borderColor ? n.borderColor : o.valueAtIndexOrDefault(a.pointBorderColor, e, s.borderColor), borderWidth: n.borderWidth ? n.borderWidth : o.valueAtIndexOrDefault(a.pointBorderWidth, e, s.borderWidth), pointStyle: n.pointStyle ? n.pointStyle : o.valueAtIndexOrDefault(a.pointStyle, e, s.pointStyle), hitRadius: n.hitRadius ? n.hitRadius : o.valueAtIndexOrDefault(a.pointHitRadius, e, s.hitRadius) } }), t._model.skip = n.skip ? n.skip : isNaN(t._model.x) || isNaN(t._model.y) }, updateBezierControlPoints: function () { var t = this.chart.chartArea, e = this.getMeta(); o.each(e.data, function (i, n) { var a = i._model, r = o.splineCurve(o.previousItem(e.data, n, !0)._model, a, o.nextItem(e.data, n, !0)._model, a.tension); a.controlPointPreviousX = Math.max(Math.min(r.previous.x, t.right), t.left), a.controlPointPreviousY = Math.max(Math.min(r.previous.y, t.bottom), t.top), a.controlPointNextX = Math.max(Math.min(r.next.x, t.right), t.left), a.controlPointNextY = Math.max(Math.min(r.next.y, t.bottom), t.top), i.pivot() }) }, setHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t.custom || {}, n = t._index, a = t._model; a.radius = i.hoverRadius ? i.hoverRadius : o.valueAtIndexOrDefault(e.pointHoverRadius, n, this.chart.options.elements.point.hoverRadius), a.backgroundColor = i.hoverBackgroundColor ? i.hoverBackgroundColor : o.valueAtIndexOrDefault(e.pointHoverBackgroundColor, n, o.getHoverColor(a.backgroundColor)), a.borderColor = i.hoverBorderColor ? i.hoverBorderColor : o.valueAtIndexOrDefault(e.pointHoverBorderColor, n, o.getHoverColor(a.borderColor)), a.borderWidth = i.hoverBorderWidth ? i.hoverBorderWidth : o.valueAtIndexOrDefault(e.pointHoverBorderWidth, n, a.borderWidth) }, removeHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t.custom || {}, n = t._index, a = t._model, r = this.chart.options.elements.point; a.radius = i.radius ? i.radius : o.valueAtIndexOrDefault(e.pointRadius, n, r.radius), a.backgroundColor = i.backgroundColor ? i.backgroundColor : o.valueAtIndexOrDefault(e.pointBackgroundColor, n, r.backgroundColor), a.borderColor = i.borderColor ? i.borderColor : o.valueAtIndexOrDefault(e.pointBorderColor, n, r.borderColor), a.borderWidth = i.borderWidth ? i.borderWidth : o.valueAtIndexOrDefault(e.pointBorderWidth, n, r.borderWidth) } }) } }, { 25: 25, 40: 40, 45: 45 }], 21: [function (t, e, i) { "use strict"; t(25)._set("scatter", { hover: { mode: "single" }, scales: { xAxes: [{ id: "x-axis-1", type: "linear", position: "bottom" }], yAxes: [{ id: "y-axis-1", type: "linear", position: "left" }] }, showLines: !1, tooltips: { callbacks: { title: function () { return "" }, label: function (t) { return "(" + t.xLabel + ", " + t.yLabel + ")" } } } }), e.exports = function (t) { t.controllers.scatter = t.controllers.line } }, { 25: 25 }], 22: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45); n._set("global", { animation: { duration: 1e3, easing: "easeOutQuart", onProgress: o.noop, onComplete: o.noop } }), e.exports = function (t) { t.Animation = a.extend({ chart: null, currentStep: 0, numSteps: 60, easing: "", render: null, onAnimationProgress: null, onAnimationComplete: null }), t.animationService = { frameDuration: 17, animations: [], dropFrames: 0, request: null, addAnimation: function (t, e, i, n) { var a, o, r = this.animations; for (e.chart = t, n || (t.animating = !0), a = 0, o = r.length; a < o; ++a)if (r[a].chart === t) return void (r[a] = e); r.push(e), 1 === r.length && this.requestAnimationFrame() }, cancelAnimation: function (t) { var e = o.findIndex(this.animations, function (e) { return e.chart === t }); -1 !== e && (this.animations.splice(e, 1), t.animating = !1) }, requestAnimationFrame: function () { var t = this; null === t.request && (t.request = o.requestAnimFrame.call(window, function () { t.request = null, t.startDigest() })) }, startDigest: function () { var t = Date.now(), e = 0; this.dropFrames > 1 && (e = Math.floor(this.dropFrames), this.dropFrames = this.dropFrames % 1), this.advance(1 + e); var i = Date.now(); this.dropFrames += (i - t) / this.frameDuration, this.animations.length > 0 && this.requestAnimationFrame() }, advance: function (t) { for (var e, i, n = this.animations, a = 0; a < n.length;)i = (e = n[a]).chart, e.currentStep = (e.currentStep || 0) + t, e.currentStep = Math.min(e.currentStep, e.numSteps), o.callback(e.render, [i, e], i), o.callback(e.onAnimationProgress, [e], i), e.currentStep >= e.numSteps ? (o.callback(e.onAnimationComplete, [e], i), i.animating = !1, n.splice(a, 1)) : ++a } }, Object.defineProperty(t.Animation.prototype, "animationObject", { get: function () { return this } }), Object.defineProperty(t.Animation.prototype, "chartInstance", { get: function () { return this.chart }, set: function (t) { this.chart = t } }) } }, { 25: 25, 26: 26, 45: 45 }], 23: [function (t, e, i) { "use strict"; var n = t(25), a = t(45), o = t(28), r = t(48); e.exports = function (t) { var e = t.plugins; t.types = {}, t.instances = {}, t.controllers = {}; function i(t) { return "top" === t || "bottom" === t } a.extend(t.prototype, { construct: function (e, i) { var o = this; i = function (t) { var e = (t = t || {}).data = t.data || {}; return e.datasets = e.datasets || [], e.labels = e.labels || [], t.options = a.configMerge(n.global, n[t.type], t.options || {}), t }(i); var s = r.acquireContext(e, i), l = s && s.canvas, h = l && l.height, u = l && l.width; o.id = a.uid(), o.ctx = s, o.canvas = l, o.config = i, o.width = u, o.height = h, o.aspectRatio = h ? u / h : null, o.options = i.options, o._bufferedRender = !1, o.chart = o, o.controller = o, t.instances[o.id] = o, Object.defineProperty(o, "data", { get: function () { return o.config.data }, set: function (t) { o.config.data = t } }), s && l ? (o.initialize(), o.update()) : console.error("Failed to create chart: can't acquire context from the given item") }, initialize: function () { return e.notify(this, "beforeInit"), a.retinaScale(this, this.options.devicePixelRatio), this.bindEvents(), this.options.responsive && this.resize(!0), this.ensureScalesHaveIDs(), this.buildOrUpdateScales(), this.initToolTip(), e.notify(this, "afterInit"), this }, clear: function () { return a.canvas.clear(this), this }, stop: function () { return t.animationService.cancelAnimation(this), this }, resize: function (t) { var i = this.options, n = this.canvas, o = i.maintainAspectRatio && this.aspectRatio || null, r = Math.max(0, Math.floor(a.getMaximumWidth(n))), s = Math.max(0, Math.floor(o ? r / o : a.getMaximumHeight(n))); if ((this.width !== r || this.height !== s) && (n.width = this.width = r, n.height = this.height = s, n.style.width = r + "px", n.style.height = s + "px", a.retinaScale(this, i.devicePixelRatio), !t)) { var l = { width: r, height: s }; e.notify(this, "resize", [l]), this.options.onResize && this.options.onResize(this, l), this.stop(), this.update(this.options.responsiveAnimationDuration) } }, ensureScalesHaveIDs: function () { var t = this.options, e = t.scales || {}, i = t.scale; a.each(e.xAxes, function (t, e) { t.id = t.id || "x-axis-" + e }), a.each(e.yAxes, function (t, e) { t.id = t.id || "y-axis-" + e }), i && (i.id = i.id || "scale") }, buildOrUpdateScales: function () { var e = this, n = e.options, o = e.scales || {}, r = [], s = Object.keys(o).reduce(function (t, e) { return t[e] = !1, t }, {}); n.scales && (r = r.concat((n.scales.xAxes || []).map(function (t) { return { options: t, dtype: "category", dposition: "bottom" } }), (n.scales.yAxes || []).map(function (t) { return { options: t, dtype: "linear", dposition: "left" } }))), n.scale && r.push({ options: n.scale, dtype: "radialLinear", isDefault: !0, dposition: "chartArea" }), a.each(r, function (n) { var r = n.options, l = r.id, h = a.valueOrDefault(r.type, n.dtype); i(r.position) !== i(n.dposition) && (r.position = n.dposition), s[l] = !0; var u = null; if (l in o && o[l].type === h) (u = o[l]).options = r, u.ctx = e.ctx, u.chart = e; else { var d = t.scaleService.getScaleConstructor(h); if (!d) return; u = new d({ id: l, type: h, options: r, ctx: e.ctx, chart: e }), o[u.id] = u } u.mergeTicksOptions(), n.isDefault && (e.scale = u) }), a.each(s, function (t, e) { t || delete o[e] }), e.scales = o, t.scaleService.addScalesToLayout(this) }, buildOrUpdateControllers: function () { var e = this, i = [], n = []; return a.each(e.data.datasets, function (a, o) { var r = e.getDatasetMeta(o), s = a.type || e.config.type; if (r.type && r.type !== s && (e.destroyDatasetMeta(o), r = e.getDatasetMeta(o)), r.type = s, i.push(r.type), r.controller) r.controller.updateIndex(o), r.controller.linkScales(); else { var l = t.controllers[r.type]; if (void 0 === l) throw new Error('"' + r.type + '" is not a chart type.'); r.controller = new l(e, o), n.push(r.controller) } }, e), n }, resetElements: function () { var t = this; a.each(t.data.datasets, function (e, i) { t.getDatasetMeta(i).controller.reset() }, t) }, reset: function () { this.resetElements(), this.tooltip.initialize() }, update: function (i) { var n = this; if (i && "object" == typeof i || (i = { duration: i, lazy: arguments[1] }), function (e) { var i = e.options; a.each(e.scales, function (i) { t.layoutService.removeBox(e, i) }), i = a.configMerge(t.defaults.global, t.defaults[e.config.type], i), e.options = e.config.options = i, e.ensureScalesHaveIDs(), e.buildOrUpdateScales(), e.tooltip._options = i.tooltips, e.tooltip.initialize() }(n), !1 !== e.notify(n, "beforeUpdate")) { n.tooltip._data = n.data; var o = n.buildOrUpdateControllers(); a.each(n.data.datasets, function (t, e) { n.getDatasetMeta(e).controller.buildOrUpdateElements() }, n), n.updateLayout(), n.options.animation && n.options.animation.duration && a.each(o, function (t) { t.reset() }), n.updateDatasets(), n.tooltip.initialize(), n.lastActive = [], e.notify(n, "afterUpdate"), n._bufferedRender ? n._bufferedRequest = { duration: i.duration, easing: i.easing, lazy: i.lazy } : n.render(i) } }, updateLayout: function () { !1 !== e.notify(this, "beforeLayout") && (t.layoutService.update(this, this.width, this.height), e.notify(this, "afterScaleUpdate"), e.notify(this, "afterLayout")) }, updateDatasets: function () { if (!1 !== e.notify(this, "beforeDatasetsUpdate")) { for (var t = 0, i = this.data.datasets.length; t < i; ++t)this.updateDataset(t); e.notify(this, "afterDatasetsUpdate") } }, updateDataset: function (t) { var i = this.getDatasetMeta(t), n = { meta: i, index: t }; !1 !== e.notify(this, "beforeDatasetUpdate", [n]) && (i.controller.update(), e.notify(this, "afterDatasetUpdate", [n])) }, render: function (i) { var n = this; i && "object" == typeof i || (i = { duration: i, lazy: arguments[1] }); var o = i.duration, r = i.lazy; if (!1 !== e.notify(n, "beforeRender")) { var s = n.options.animation, l = function (t) { e.notify(n, "afterRender"), a.callback(s && s.onComplete, [t], n) }; if (s && (void 0 !== o && 0 !== o || void 0 === o && 0 !== s.duration)) { var h = new t.Animation({ numSteps: (o || s.duration) / 16.66, easing: i.easing || s.easing, render: function (t, e) { var i = a.easing.effects[e.easing], n = e.currentStep, o = n / e.numSteps; t.draw(i(o), o, n) }, onAnimationProgress: s.onProgress, onAnimationComplete: l }); t.animationService.addAnimation(n, h, o, r) } else n.draw(), l(new t.Animation({ numSteps: 0, chart: n })); return n } }, draw: function (t) { var i = this; i.clear(), a.isNullOrUndef(t) && (t = 1), i.transition(t), !1 !== e.notify(i, "beforeDraw", [t]) && (a.each(i.boxes, function (t) { t.draw(i.chartArea) }, i), i.scale && i.scale.draw(), i.drawDatasets(t), i._drawTooltip(t), e.notify(i, "afterDraw", [t])) }, transition: function (t) { for (var e = 0, i = (this.data.datasets || []).length; e < i; ++e)this.isDatasetVisible(e) && this.getDatasetMeta(e).controller.transition(t); this.tooltip.transition(t) }, drawDatasets: function (t) { if (!1 !== e.notify(this, "beforeDatasetsDraw", [t])) { for (var i = (this.data.datasets || []).length - 1; i >= 0; --i)this.isDatasetVisible(i) && this.drawDataset(i, t); e.notify(this, "afterDatasetsDraw", [t]) } }, drawDataset: function (t, i) { var n = this.getDatasetMeta(t), a = { meta: n, index: t, easingValue: i }; !1 !== e.notify(this, "beforeDatasetDraw", [a]) && (n.controller.draw(i), e.notify(this, "afterDatasetDraw", [a])) }, _drawTooltip: function (t) { var i = this.tooltip, n = { tooltip: i, easingValue: t }; !1 !== e.notify(this, "beforeTooltipDraw", [n]) && (i.draw(), e.notify(this, "afterTooltipDraw", [n])) }, getElementAtEvent: function (t) { return o.modes.single(this, t) }, getElementsAtEvent: function (t) { return o.modes.label(this, t, { intersect: !0 }) }, getElementsAtXAxis: function (t) { return o.modes["x-axis"](this, t, { intersect: !0 }) }, getElementsAtEventForMode: function (t, e, i) { var n = o.modes[e]; return "function" == typeof n ? n(this, t, i) : [] }, getDatasetAtEvent: function (t) { return o.modes.dataset(this, t, { intersect: !0 }) }, getDatasetMeta: function (t) { var e = this.data.datasets[t]; e._meta || (e._meta = {}); var i = e._meta[this.id]; return i || (i = e._meta[this.id] = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null }), i }, getVisibleDatasetCount: function () { for (var t = 0, e = 0, i = this.data.datasets.length; e < i; ++e)this.isDatasetVisible(e) && t++; return t }, isDatasetVisible: function (t) { var e = this.getDatasetMeta(t); return "boolean" == typeof e.hidden ? !e.hidden : !this.data.datasets[t].hidden }, generateLegend: function () { return this.options.legendCallback(this) }, destroyDatasetMeta: function (t) { var e = this.id, i = this.data.datasets[t], n = i._meta && i._meta[e]; n && (n.controller.destroy(), delete i._meta[e]) }, destroy: function () { var i, n, o = this.canvas; for (this.stop(), i = 0, n = this.data.datasets.length; i < n; ++i)this.destroyDatasetMeta(i); o && (this.unbindEvents(), a.canvas.clear(this), r.releaseContext(this.ctx), this.canvas = null, this.ctx = null), e.notify(this, "destroy"), delete t.instances[this.id] }, toBase64Image: function () { return this.canvas.toDataURL.apply(this.canvas, arguments) }, initToolTip: function () { this.tooltip = new t.Tooltip({ _chart: this, _chartInstance: this, _data: this.data, _options: this.options.tooltips }, this) }, bindEvents: function () { var t = this, e = t._listeners = {}, i = function () { t.eventHandler.apply(t, arguments) }; a.each(t.options.events, function (n) { r.addEventListener(t, n, i), e[n] = i }), t.options.responsive && (i = function () { t.resize() }, r.addEventListener(t, "resize", i), e.resize = i) }, unbindEvents: function () { var t = this, e = t._listeners; e && (delete t._listeners, a.each(e, function (e, i) { r.removeEventListener(t, i, e) })) }, updateHoverStyle: function (t, e, i) { var n, a, o, r = i ? "setHoverStyle" : "removeHoverStyle"; for (a = 0, o = t.length; a < o; ++a)(n = t[a]) && this.getDatasetMeta(n._datasetIndex).controller[r](n) }, eventHandler: function (t) { var i = this.tooltip; if (!1 !== e.notify(this, "beforeEvent", [t])) { this._bufferedRender = !0, this._bufferedRequest = null; var n = this.handleEvent(t); i && (n = i._start ? i.handleEvent(t) : n | i.handleEvent(t)), e.notify(this, "afterEvent", [t]); var a = this._bufferedRequest; return a ? this.render(a) : n && !this.animating && (this.stop(), this.render(this.options.hover.animationDuration, !0)), this._bufferedRender = !1, this._bufferedRequest = null, this } }, handleEvent: function (t) { var e = this.options || {}, i = e.hover, n = !1; return this.lastActive = this.lastActive || [], "mouseout" === t.type ? this.active = [] : this.active = this.getElementsAtEventForMode(t, i.mode, i), a.callback(e.onHover || e.hover.onHover, [t.native, this.active], this), "mouseup" !== t.type && "click" !== t.type || e.onClick && e.onClick.call(this, t.native, this.active), this.lastActive.length && this.updateHoverStyle(this.lastActive, i.mode, !1), this.active.length && i.mode && this.updateHoverStyle(this.active, i.mode, !0), n = !a.arrayEquals(this.active, this.lastActive), this.lastActive = this.active, n } }), t.Controller = t } }, { 25: 25, 28: 28, 45: 45, 48: 48 }], 24: [function (t, e, i) { "use strict"; var n = t(45); e.exports = function (t) { var e = ["push", "pop", "shift", "splice", "unshift"]; function i(t, i) { var n = t._chartjs; if (n) { var a = n.listeners, o = a.indexOf(i); -1 !== o && a.splice(o, 1), a.length > 0 || (e.forEach(function (e) { delete t[e] }), delete t._chartjs) } } t.DatasetController = function (t, e) { this.initialize(t, e) }, n.extend(t.DatasetController.prototype, { datasetElementType: null, dataElementType: null, initialize: function (t, e) { this.chart = t, this.index = e, this.linkScales(), this.addElements() }, updateIndex: function (t) { this.index = t }, linkScales: function () { var t = this.getMeta(), e = this.getDataset(); null !== t.xAxisID && t.xAxisID in this.chart.scales || (t.xAxisID = e.xAxisID || this.chart.options.scales.xAxes[0].id), null !== t.yAxisID && t.yAxisID in this.chart.scales || (t.yAxisID = e.yAxisID || this.chart.options.scales.yAxes[0].id) }, getDataset: function () { return this.chart.data.datasets[this.index] }, getMeta: function () { return this.chart.getDatasetMeta(this.index) }, getScaleForId: function (t) { return this.chart.scales[t] }, reset: function () { this.update(!0) }, destroy: function () { this._data && i(this._data, this) }, createMetaDataset: function () { var t = this.datasetElementType; return t && new t({ _chart: this.chart, _datasetIndex: this.index }) }, createMetaData: function (t) { var e = this.dataElementType; return e && new e({ _chart: this.chart, _datasetIndex: this.index, _index: t }) }, addElements: function () { var t, e, i = this.getMeta(), n = this.getDataset().data || [], a = i.data; for (t = 0, e = n.length; t < e; ++t)a[t] = a[t] || this.createMetaData(t); i.dataset = i.dataset || this.createMetaDataset() }, addElementAndReset: function (t) { var e = this.createMetaData(t); this.getMeta().data.splice(t, 0, e), this.updateElement(e, t, !0) }, buildOrUpdateElements: function () { var t = this.getDataset(), a = t.data || (t.data = []); this._data !== a && (this._data && i(this._data, this), r = this, (o = a)._chartjs ? o._chartjs.listeners.push(r) : (Object.defineProperty(o, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [r] } }), e.forEach(function (t) { var e = "onData" + t.charAt(0).toUpperCase() + t.slice(1), i = o[t]; Object.defineProperty(o, t, { configurable: !0, enumerable: !1, value: function () { var t = Array.prototype.slice.call(arguments), a = i.apply(this, t); return n.each(o._chartjs.listeners, function (i) { "function" == typeof i[e] && i[e].apply(i, t) }), a } }) })), this._data = a); var o, r; this.resyncElements() }, update: n.noop, transition: function (t) { for (var e = this.getMeta(), i = e.data || [], n = i.length, a = 0; a < n; ++a)i[a].transition(t); e.dataset && e.dataset.transition(t) }, draw: function () { var t = this.getMeta(), e = t.data || [], i = e.length, n = 0; for (t.dataset && t.dataset.draw(); n < i; ++n)e[n].draw() }, removeHoverStyle: function (t, e) { var i = this.chart.data.datasets[t._datasetIndex], a = t._index, o = t.custom || {}, r = n.valueAtIndexOrDefault, s = t._model; s.backgroundColor = o.backgroundColor ? o.backgroundColor : r(i.backgroundColor, a, e.backgroundColor), s.borderColor = o.borderColor ? o.borderColor : r(i.borderColor, a, e.borderColor), s.borderWidth = o.borderWidth ? o.borderWidth : r(i.borderWidth, a, e.borderWidth) }, setHoverStyle: function (t) { var e = this.chart.data.datasets[t._datasetIndex], i = t._index, a = t.custom || {}, o = n.valueAtIndexOrDefault, r = n.getHoverColor, s = t._model; s.backgroundColor = a.hoverBackgroundColor ? a.hoverBackgroundColor : o(e.hoverBackgroundColor, i, r(s.backgroundColor)), s.borderColor = a.hoverBorderColor ? a.hoverBorderColor : o(e.hoverBorderColor, i, r(s.borderColor)), s.borderWidth = a.hoverBorderWidth ? a.hoverBorderWidth : o(e.hoverBorderWidth, i, s.borderWidth) }, resyncElements: function () { var t = this.getMeta(), e = this.getDataset().data, i = t.data.length, n = e.length; n < i ? t.data.splice(n, i - n) : n > i && this.insertElements(i, n - i) }, insertElements: function (t, e) { for (var i = 0; i < e; ++i)this.addElementAndReset(t + i) }, onDataPush: function () { this.insertElements(this.getDataset().data.length - 1, arguments.length) }, onDataPop: function () { this.getMeta().data.pop() }, onDataShift: function () { this.getMeta().data.shift() }, onDataSplice: function (t, e) { this.getMeta().data.splice(t, e), this.insertElements(t, arguments.length - 2) }, onDataUnshift: function () { this.insertElements(0, arguments.length) } }), t.DatasetController.extend = n.inherits } }, { 45: 45 }], 25: [function (t, e, i) { "use strict"; var n = t(45); e.exports = { _set: function (t, e) { return n.merge(this[t] || (this[t] = {}), e) } } }, { 45: 45 }], 26: [function (t, e, i) { "use strict"; var n = t(3), a = t(45); var o = function (t) { a.extend(this, t), this.initialize.apply(this, arguments) }; a.extend(o.prototype, { initialize: function () { this.hidden = !1 }, pivot: function () { return this._view || (this._view = a.clone(this._model)), this._start = {}, this }, transition: function (t) { var e = this._model, i = this._start, a = this._view; return e && 1 !== t ? (a || (a = this._view = {}), i || (i = this._start = {}), function (t, e, i, a) { var o, r, s, l, h, u, d, c, f, g = Object.keys(i); for (o = 0, r = g.length; o < r; ++o)if (u = i[s = g[o]], e.hasOwnProperty(s) || (e[s] = u), (l = e[s]) !== u && "_" !== s[0]) { if (t.hasOwnProperty(s) || (t[s] = l), (d = typeof u) == typeof (h = t[s])) if ("string" === d) { if ((c = n(h)).valid && (f = n(u)).valid) { e[s] = f.mix(c, a).rgbString(); continue } } else if ("number" === d && isFinite(h) && isFinite(u)) { e[s] = h + (u - h) * a; continue } e[s] = u } }(i, a, e, t), this) : (this._view = e, this._start = null, this) }, tooltipPosition: function () { return { x: this._model.x, y: this._model.y } }, hasValue: function () { return a.isNumber(this._model.x) && a.isNumber(this._model.y) } }), o.extend = a.inherits, e.exports = o }, { 3: 3, 45: 45 }], 27: [function (t, e, i) { "use strict"; var n = t(3), a = t(25), o = t(45); e.exports = function (t) { o.configMerge = function () { return o.merge(o.clone(arguments[0]), [].slice.call(arguments, 1), { merger: function (e, i, n, a) { var r = i[e] || {}, s = n[e]; "scales" === e ? i[e] = o.scaleMerge(r, s) : "scale" === e ? i[e] = o.merge(r, [t.scaleService.getScaleDefaults(s.type), s]) : o._merger(e, i, n, a) } }) }, o.scaleMerge = function () { return o.merge(o.clone(arguments[0]), [].slice.call(arguments, 1), { merger: function (e, i, n, a) { if ("xAxes" === e || "yAxes" === e) { var r, s, l, h = n[e].length; for (i[e] || (i[e] = []), r = 0; r < h; ++r)l = n[e][r], s = o.valueOrDefault(l.type, "xAxes" === e ? "category" : "linear"), r >= i[e].length && i[e].push({}), !i[e][r].type || l.type && l.type !== i[e][r].type ? o.merge(i[e][r], [t.scaleService.getScaleDefaults(s), l]) : o.merge(i[e][r], l) } else o._merger(e, i, n, a) } }) }, o.where = function (t, e) { if (o.isArray(t) && Array.prototype.filter) return t.filter(e); var i = []; return o.each(t, function (t) { e(t) && i.push(t) }), i }, o.findIndex = Array.prototype.findIndex ? function (t, e, i) { return t.findIndex(e, i) } : function (t, e, i) { i = void 0 === i ? t : i; for (var n = 0, a = t.length; n < a; ++n)if (e.call(i, t[n], n, t)) return n; return -1 }, o.findNextWhere = function (t, e, i) { o.isNullOrUndef(i) && (i = -1); for (var n = i + 1; n < t.length; n++) { var a = t[n]; if (e(a)) return a } }, o.findPreviousWhere = function (t, e, i) { o.isNullOrUndef(i) && (i = t.length); for (var n = i - 1; n >= 0; n--) { var a = t[n]; if (e(a)) return a } }, o.isNumber = function (t) { return !isNaN(parseFloat(t)) && isFinite(t) }, o.almostEquals = function (t, e, i) { return Math.abs(t - e) < i }, o.almostWhole = function (t, e) { var i = Math.round(t); return i - e < t && i + e > t }, o.max = function (t) { return t.reduce(function (t, e) { return isNaN(e) ? t : Math.max(t, e) }, Number.NEGATIVE_INFINITY) }, o.min = function (t) { return t.reduce(function (t, e) { return isNaN(e) ? t : Math.min(t, e) }, Number.POSITIVE_INFINITY) }, o.sign = Math.sign ? function (t) { return Math.sign(t) } : function (t) { return 0 === (t = +t) || isNaN(t) ? t : t > 0 ? 1 : -1 }, o.log10 = Math.log10 ? function (t) { return Math.log10(t) } : function (t) { return Math.log(t) / Math.LN10 }, o.toRadians = function (t) { return t * (Math.PI / 180) }, o.toDegrees = function (t) { return t * (180 / Math.PI) }, o.getAngleFromPoint = function (t, e) { var i = e.x - t.x, n = e.y - t.y, a = Math.sqrt(i * i + n * n), o = Math.atan2(n, i); return o < -.5 * Math.PI && (o += 2 * Math.PI), { angle: o, distance: a } }, o.distanceBetweenPoints = function (t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) }, o.aliasPixel = function (t) { return t % 2 == 0 ? 0 : .5 }, o.splineCurve = function (t, e, i, n) { var a = t.skip ? e : t, o = e, r = i.skip ? e : i, s = Math.sqrt(Math.pow(o.x - a.x, 2) + Math.pow(o.y - a.y, 2)), l = Math.sqrt(Math.pow(r.x - o.x, 2) + Math.pow(r.y - o.y, 2)), h = s / (s + l), u = l / (s + l), d = n * (h = isNaN(h) ? 0 : h), c = n * (u = isNaN(u) ? 0 : u); return { previous: { x: o.x - d * (r.x - a.x), y: o.y - d * (r.y - a.y) }, next: { x: o.x + c * (r.x - a.x), y: o.y + c * (r.y - a.y) } } }, o.EPSILON = Number.EPSILON || 1e-14, o.splineCurveMonotone = function (t) { var e, i, n, a, r = (t || []).map(function (t) { return { model: t._model, deltaK: 0, mK: 0 } }), s = r.length; for (e = 0; e < s; ++e)if (!(n = r[e]).model.skip) { if (i = e > 0 ? r[e - 1] : null, (a = e < s - 1 ? r[e + 1] : null) && !a.model.skip) { var l = a.model.x - n.model.x; n.deltaK = 0 !== l ? (a.model.y - n.model.y) / l : 0 } !i || i.model.skip ? n.mK = n.deltaK : !a || a.model.skip ? n.mK = i.deltaK : this.sign(i.deltaK) !== this.sign(n.deltaK) ? n.mK = 0 : n.mK = (i.deltaK + n.deltaK) / 2 } var h, u, d, c; for (e = 0; e < s - 1; ++e)n = r[e], a = r[e + 1], n.model.skip || a.model.skip || (o.almostEquals(n.deltaK, 0, this.EPSILON) ? n.mK = a.mK = 0 : (h = n.mK / n.deltaK, u = a.mK / n.deltaK, (c = Math.pow(h, 2) + Math.pow(u, 2)) <= 9 || (d = 3 / Math.sqrt(c), n.mK = h * d * n.deltaK, a.mK = u * d * n.deltaK))); var f; for (e = 0; e < s; ++e)(n = r[e]).model.skip || (i = e > 0 ? r[e - 1] : null, a = e < s - 1 ? r[e + 1] : null, i && !i.model.skip && (f = (n.model.x - i.model.x) / 3, n.model.controlPointPreviousX = n.model.x - f, n.model.controlPointPreviousY = n.model.y - f * n.mK), a && !a.model.skip && (f = (a.model.x - n.model.x) / 3, n.model.controlPointNextX = n.model.x + f, n.model.controlPointNextY = n.model.y + f * n.mK)) }, o.nextItem = function (t, e, i) { return i ? e >= t.length - 1 ? t[0] : t[e + 1] : e >= t.length - 1 ? t[t.length - 1] : t[e + 1] }, o.previousItem = function (t, e, i) { return i ? e <= 0 ? t[t.length - 1] : t[e - 1] : e <= 0 ? t[0] : t[e - 1] }, o.niceNum = function (t, e) { var i = Math.floor(o.log10(t)), n = t / Math.pow(10, i); return (e ? n < 1.5 ? 1 : n < 3 ? 2 : n < 7 ? 5 : 10 : n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * Math.pow(10, i) }, o.requestAnimFrame = "undefined" == typeof window ? function (t) { t() } : window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) { return window.setTimeout(t, 1e3 / 60) }, o.getRelativePosition = function (t, e) { var i, n, a = t.originalEvent || t, r = t.currentTarget || t.srcElement, s = r.getBoundingClientRect(), l = a.touches; l && l.length > 0 ? (i = l[0].clientX, n = l[0].clientY) : (i = a.clientX, n = a.clientY); var h = parseFloat(o.getStyle(r, "padding-left")), u = parseFloat(o.getStyle(r, "padding-top")), d = parseFloat(o.getStyle(r, "padding-right")), c = parseFloat(o.getStyle(r, "padding-bottom")), f = s.right - s.left - h - d, g = s.bottom - s.top - u - c; return { x: i = Math.round((i - s.left - h) / f * r.width / e.currentDevicePixelRatio), y: n = Math.round((n - s.top - u) / g * r.height / e.currentDevicePixelRatio) } }; function e(t, e, i) { var n; return "string" == typeof t ? (n = parseInt(t, 10), -1 !== t.indexOf("%") && (n = n / 100 * e.parentNode[i])) : n = t, n } function i(t) { return void 0 !== t && null !== t && "none" !== t } function r(t, n, a) { var o = document.defaultView, r = t.parentNode, s = o.getComputedStyle(t)[n], l = o.getComputedStyle(r)[n], h = i(s), u = i(l), d = Number.POSITIVE_INFINITY; return h || u ? Math.min(h ? e(s, t, a) : d, u ? e(l, r, a) : d) : "none" } o.getConstraintWidth = function (t) { return r(t, "max-width", "clientWidth") }, o.getConstraintHeight = function (t) { return r(t, "max-height", "clientHeight") }, o.getMaximumWidth = function (t) { var e = t.parentNode; if (!e) return t.clientWidth; var i = parseInt(o.getStyle(e, "padding-left"), 10), n = parseInt(o.getStyle(e, "padding-right"), 10), a = e.clientWidth - i - n, r = o.getConstraintWidth(t); return isNaN(r) ? a : Math.min(a, r) }, o.getMaximumHeight = function (t) { var e = t.parentNode; if (!e) return t.clientHeight; var i = parseInt(o.getStyle(e, "padding-top"), 10), n = parseInt(o.getStyle(e, "padding-bottom"), 10), a = e.clientHeight - i - n, r = o.getConstraintHeight(t); return isNaN(r) ? a : Math.min(a, r) }, o.getStyle = function (t, e) { return t.currentStyle ? t.currentStyle[e] : document.defaultView.getComputedStyle(t, null).getPropertyValue(e) }, o.retinaScale = function (t, e) { var i = t.currentDevicePixelRatio = e || window.devicePixelRatio || 1; if (1 !== i) { var n = t.canvas, a = t.height, o = t.width; n.height = a * i, n.width = o * i, t.ctx.scale(i, i), n.style.height || n.style.width || (n.style.height = a + "px", n.style.width = o + "px") } }, o.fontString = function (t, e, i) { return e + " " + t + "px " + i }, o.longestText = function (t, e, i, n) { var a = (n = n || {}).data = n.data || {}, r = n.garbageCollect = n.garbageCollect || []; n.font !== e && (a = n.data = {}, r = n.garbageCollect = [], n.font = e), t.font = e; var s = 0; o.each(i, function (e) { void 0 !== e && null !== e && !0 !== o.isArray(e) ? s = o.measureText(t, a, r, s, e) : o.isArray(e) && o.each(e, function (e) { void 0 === e || null === e || o.isArray(e) || (s = o.measureText(t, a, r, s, e)) }) }); var l = r.length / 2; if (l > i.length) { for (var h = 0; h < l; h++)delete a[r[h]]; r.splice(0, l) } return s }, o.measureText = function (t, e, i, n, a) { var o = e[a]; return o || (o = e[a] = t.measureText(a).width, i.push(a)), o > n && (n = o), n }, o.numberOfLabelLines = function (t) { var e = 1; return o.each(t, function (t) { o.isArray(t) && t.length > e && (e = t.length) }), e }, o.color = n ? function (t) { return t instanceof CanvasGradient && (t = a.global.defaultColor), n(t) } : function (t) { return console.error("Color.js not found!"), t }, o.getHoverColor = function (t) { return t instanceof CanvasPattern ? t : o.color(t).saturate(.5).darken(.1).rgbString() } } }, { 25: 25, 3: 3, 45: 45 }], 28: [function (t, e, i) { "use strict"; var n = t(45); function a(t, e) { return t.native ? { x: t.x, y: t.y } : n.getRelativePosition(t, e) } function o(t, e) { var i, n, a, o, r; for (n = 0, o = t.data.datasets.length; n < o; ++n)if (t.isDatasetVisible(n)) for (a = 0, r = (i = t.getDatasetMeta(n)).data.length; a < r; ++a) { var s = i.data[a]; s._view.skip || e(s) } } function r(t, e) { var i = []; return o(t, function (t) { t.inRange(e.x, e.y) && i.push(t) }), i } function s(t, e, i, n) { var a = Number.POSITIVE_INFINITY, r = []; return o(t, function (t) { if (!i || t.inRange(e.x, e.y)) { var o = t.getCenterPoint(), s = n(e, o); s < a ? (r = [t], a = s) : s === a && r.push(t) } }), r } function l(t) { var e = -1 !== t.indexOf("x"), i = -1 !== t.indexOf("y"); return function (t, n) { var a = e ? Math.abs(t.x - n.x) : 0, o = i ? Math.abs(t.y - n.y) : 0; return Math.sqrt(Math.pow(a, 2) + Math.pow(o, 2)) } } function h(t, e, i) { var n = a(e, t); i.axis = i.axis || "x"; var o = l(i.axis), h = i.intersect ? r(t, n) : s(t, n, !1, o), u = []; return h.length ? (t.data.datasets.forEach(function (e, i) { if (t.isDatasetVisible(i)) { var n = t.getDatasetMeta(i).data[h[0]._index]; n && !n._view.skip && u.push(n) } }), u) : [] } e.exports = { modes: { single: function (t, e) { var i = a(e, t), n = []; return o(t, function (t) { if (t.inRange(i.x, i.y)) return n.push(t), n }), n.slice(0, 1) }, label: h, index: h, dataset: function (t, e, i) { var n = a(e, t); i.axis = i.axis || "xy"; var o = l(i.axis), h = i.intersect ? r(t, n) : s(t, n, !1, o); return h.length > 0 && (h = t.getDatasetMeta(h[0]._datasetIndex).data), h }, "x-axis": function (t, e) { return h(t, e, { intersect: !1 }) }, point: function (t, e) { return r(t, a(e, t)) }, nearest: function (t, e, i) { var n = a(e, t); i.axis = i.axis || "xy"; var o = l(i.axis), r = s(t, n, i.intersect, o); return r.length > 1 && r.sort(function (t, e) { var i = t.getArea() - e.getArea(); return 0 === i && (i = t._datasetIndex - e._datasetIndex), i }), r.slice(0, 1) }, x: function (t, e, i) { var n = a(e, t), r = [], s = !1; return o(t, function (t) { t.inXRange(n.x) && r.push(t), t.inRange(n.x, n.y) && (s = !0) }), i.intersect && !s && (r = []), r }, y: function (t, e, i) { var n = a(e, t), r = [], s = !1; return o(t, function (t) { t.inYRange(n.y) && r.push(t), t.inRange(n.x, n.y) && (s = !0) }), i.intersect && !s && (r = []), r } } } }, { 45: 45 }], 29: [function (t, e, i) { "use strict"; t(25)._set("global", { responsive: !0, responsiveAnimationDuration: 0, maintainAspectRatio: !0, events: ["mousemove", "mouseout", "click", "touchstart", "touchmove"], hover: { onHover: null, mode: "nearest", intersect: !0, animationDuration: 400 }, onClick: null, defaultColor: "rgba(0,0,0,0.1)", defaultFontColor: "#666", defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", defaultFontSize: 12, defaultFontStyle: "normal", showLines: !0, elements: {}, layout: { padding: { top: 0, right: 0, bottom: 0, left: 0 } } }), e.exports = function () { var t = function (t, e) { return this.construct(t, e), this }; return t.Chart = t, t } }, { 25: 25 }], 30: [function (t, e, i) { "use strict"; var n = t(45); e.exports = function (t) { function e(t, e) { return n.where(t, function (t) { return t.position === e }) } function i(t, e) { t.forEach(function (t, e) { return t._tmpIndex_ = e, t }), t.sort(function (t, i) { var n = e ? i : t, a = e ? t : i; return n.weight === a.weight ? n._tmpIndex_ - a._tmpIndex_ : n.weight - a.weight }), t.forEach(function (t) { delete t._tmpIndex_ }) } t.layoutService = { defaults: {}, addBox: function (t, e) { t.boxes || (t.boxes = []), e.fullWidth = e.fullWidth || !1, e.position = e.position || "top", e.weight = e.weight || 0, t.boxes.push(e) }, removeBox: function (t, e) { var i = t.boxes ? t.boxes.indexOf(e) : -1; -1 !== i && t.boxes.splice(i, 1) }, configure: function (t, e, i) { for (var n, a = ["fullWidth", "position", "weight"], o = a.length, r = 0; r < o; ++r)n = a[r], i.hasOwnProperty(n) && (e[n] = i[n]) }, update: function (t, a, o) { if (t) { var r = t.options.layout || {}, s = n.options.toPadding(r.padding), l = s.left, h = s.right, u = s.top, d = s.bottom, c = e(t.boxes, "left"), f = e(t.boxes, "right"), g = e(t.boxes, "top"), p = e(t.boxes, "bottom"), v = e(t.boxes, "chartArea"); i(c, !0), i(f, !1), i(g, !0), i(p, !1); var m = a - l - h, b = o - u - d, x = b / 2, y = (a - m / 2) / (c.length + f.length), k = (o - x) / (g.length + p.length), w = m, M = b, S = []; n.each(c.concat(f, g, p), function (t) { var e, i = t.isHorizontal(); i ? (e = t.update(t.fullWidth ? m : w, k), M -= e.height) : (e = t.update(y, M), w -= e.width), S.push({ horizontal: i, minSize: e, box: t }) }); var C = 0, _ = 0, D = 0, I = 0; n.each(g.concat(p), function (t) { if (t.getPadding) { var e = t.getPadding(); C = Math.max(C, e.left), _ = Math.max(_, e.right) } }), n.each(c.concat(f), function (t) { if (t.getPadding) { var e = t.getPadding(); D = Math.max(D, e.top), I = Math.max(I, e.bottom) } }); var P = l, A = h, T = u, F = d; n.each(c.concat(f), N), n.each(c, function (t) { P += t.width }), n.each(f, function (t) { A += t.width }), n.each(g.concat(p), N), n.each(g, function (t) { T += t.height }), n.each(p, function (t) { F += t.height }), n.each(c.concat(f), function (t) { var e = n.findNextWhere(S, function (e) { return e.box === t }), i = { left: 0, right: 0, top: T, bottom: F }; e && t.update(e.minSize.width, M, i) }), P = l, A = h, T = u, F = d, n.each(c, function (t) { P += t.width }), n.each(f, function (t) { A += t.width }), n.each(g, function (t) { T += t.height }), n.each(p, function (t) { F += t.height }); var O = Math.max(C - P, 0); P += O, A += Math.max(_ - A, 0); var R = Math.max(D - T, 0); T += R, F += Math.max(I - F, 0); var L = o - T - F, z = a - P - A; z === w && L === M || (n.each(c, function (t) { t.height = L }), n.each(f, function (t) { t.height = L }), n.each(g, function (t) { t.fullWidth || (t.width = z) }), n.each(p, function (t) { t.fullWidth || (t.width = z) }), M = L, w = z); var B = l + O, W = u + R; n.each(c.concat(g), V), B += w, W += M, n.each(f, V), n.each(p, V), t.chartArea = { left: P, top: T, right: P + w, bottom: T + M }, n.each(v, function (e) { e.left = t.chartArea.left, e.top = t.chartArea.top, e.right = t.chartArea.right, e.bottom = t.chartArea.bottom, e.update(w, M) }) } function N(t) { var e = n.findNextWhere(S, function (e) { return e.box === t }); if (e) if (t.isHorizontal()) { var i = { left: Math.max(P, C), right: Math.max(A, _), top: 0, bottom: 0 }; t.update(t.fullWidth ? m : w, b / 2, i) } else t.update(e.minSize.width, M) } function V(t) { t.isHorizontal() ? (t.left = t.fullWidth ? l : P, t.right = t.fullWidth ? a - h : P + w, t.top = W, t.bottom = W + t.height, W = t.bottom) : (t.left = B, t.right = B + t.width, t.top = T, t.bottom = T + M, B = t.right) } } } } }, { 45: 45 }], 31: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45); n._set("global", { plugins: {} }), e.exports = function (t) { t.plugins = { _plugins: [], _cacheId: 0, register: function (t) { var e = this._plugins;[].concat(t).forEach(function (t) { -1 === e.indexOf(t) && e.push(t) }), this._cacheId++ }, unregister: function (t) { var e = this._plugins;[].concat(t).forEach(function (t) { var i = e.indexOf(t); -1 !== i && e.splice(i, 1) }), this._cacheId++ }, clear: function () { this._plugins = [], this._cacheId++ }, count: function () { return this._plugins.length }, getAll: function () { return this._plugins }, notify: function (t, e, i) { var n, a, o, r, s, l = this.descriptors(t), h = l.length; for (n = 0; n < h; ++n)if ("function" == typeof (s = (o = (a = l[n]).plugin)[e]) && ((r = [t].concat(i || [])).push(a.options), !1 === s.apply(o, r))) return !1; return !0 }, descriptors: function (t) { var e = t._plugins || (t._plugins = {}); if (e.id === this._cacheId) return e.descriptors; var i = [], a = [], r = t && t.config || {}, s = r.options && r.options.plugins || {}; return this._plugins.concat(r.plugins || []).forEach(function (t) { if (-1 === i.indexOf(t)) { var e = t.id, r = s[e]; !1 !== r && (!0 === r && (r = o.clone(n.global.plugins[e])), i.push(t), a.push({ plugin: t, options: r || {} })) } }), e.descriptors = a, e.id = this._cacheId, a } }, t.pluginService = t.plugins, t.PluginBase = a.extend({}) } }, { 25: 25, 26: 26, 45: 45 }], 32: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45), r = t(34); n._set("scale", { display: !0, position: "left", offset: !1, gridLines: { display: !0, color: "rgba(0, 0, 0, 0.1)", lineWidth: 1, drawBorder: !0, drawOnChartArea: !0, drawTicks: !0, tickMarkLength: 10, zeroLineWidth: 1, zeroLineColor: "rgba(0,0,0,0.25)", zeroLineBorderDash: [], zeroLineBorderDashOffset: 0, offsetGridLines: !1, borderDash: [], borderDashOffset: 0 }, scaleLabel: { display: !1, labelString: "", lineHeight: 1.2, padding: { top: 4, bottom: 4 } }, ticks: { beginAtZero: !1, minRotation: 0, maxRotation: 50, mirror: !1, padding: 0, reverse: !1, display: !0, autoSkip: !0, autoSkipPadding: 0, labelOffset: 0, callback: r.formatters.values, minor: {}, major: {} } }); function s(t) { var e, i, n = []; for (e = 0, i = t.length; e < i; ++e)n.push(t[e].label); return n } function l(t, e, i) { var n = t.getPixelForTick(e); return i && (n -= 0 === e ? (t.getPixelForTick(1) - n) / 2 : (n - t.getPixelForTick(e - 1)) / 2), n } e.exports = function (t) { function e(t, e, i) { return o.isArray(e) ? o.longestText(t, i, e) : t.measureText(e).width } function i(t) { var e = o.valueOrDefault, i = n.global, a = e(t.fontSize, i.defaultFontSize), r = e(t.fontStyle, i.defaultFontStyle), s = e(t.fontFamily, i.defaultFontFamily); return { size: a, style: r, family: s, font: o.fontString(a, r, s) } } function r(t) { return o.options.toLineHeight(o.valueOrDefault(t.lineHeight, 1.2), o.valueOrDefault(t.fontSize, n.global.defaultFontSize)) } t.Scale = a.extend({ getPadding: function () { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 } }, getTicks: function () { return this._ticks }, mergeTicksOptions: function () { var t = this.options.ticks; !1 === t.minor && (t.minor = { display: !1 }), !1 === t.major && (t.major = { display: !1 }); for (var e in t) "major" !== e && "minor" !== e && (void 0 === t.minor[e] && (t.minor[e] = t[e]), void 0 === t.major[e] && (t.major[e] = t[e])) }, beforeUpdate: function () { o.callback(this.options.beforeUpdate, [this]) }, update: function (t, e, i) { var n, a, r, s, l, h; for (this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this.margins = o.extend({ left: 0, right: 0, top: 0, bottom: 0 }, i), this.longestTextCache = this.longestTextCache || {}, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this.beforeBuildTicks(), l = this.buildTicks() || [], this.afterBuildTicks(), this.beforeTickToLabelConversion(), r = this.convertTicksToLabels(l) || this.ticks, this.afterTickToLabelConversion(), this.ticks = r, n = 0, a = r.length; n < a; ++n)s = r[n], (h = l[n]) ? h.label = s : l.push(h = { label: s, major: !1 }); return this._ticks = l, this.beforeCalculateTickRotation(), this.calculateTickRotation(), this.afterCalculateTickRotation(), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate(), this.minSize }, afterUpdate: function () { o.callback(this.options.afterUpdate, [this]) }, beforeSetDimensions: function () { o.callback(this.options.beforeSetDimensions, [this]) }, setDimensions: function () { this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0 }, afterSetDimensions: function () { o.callback(this.options.afterSetDimensions, [this]) }, beforeDataLimits: function () { o.callback(this.options.beforeDataLimits, [this]) }, determineDataLimits: o.noop, afterDataLimits: function () { o.callback(this.options.afterDataLimits, [this]) }, beforeBuildTicks: function () { o.callback(this.options.beforeBuildTicks, [this]) }, buildTicks: o.noop, afterBuildTicks: function () { o.callback(this.options.afterBuildTicks, [this]) }, beforeTickToLabelConversion: function () { o.callback(this.options.beforeTickToLabelConversion, [this]) }, convertTicksToLabels: function () { var t = this.options.ticks; this.ticks = this.ticks.map(t.userCallback || t.callback, this) }, afterTickToLabelConversion: function () { o.callback(this.options.afterTickToLabelConversion, [this]) }, beforeCalculateTickRotation: function () { o.callback(this.options.beforeCalculateTickRotation, [this]) }, calculateTickRotation: function () { var t = this.ctx, e = this.options.ticks, n = s(this._ticks), a = i(e); t.font = a.font; var r = e.minRotation || 0; if (n.length && this.options.display && this.isHorizontal()) for (var l, h = o.longestText(t, a.font, n, this.longestTextCache), u = h, d = this.getPixelForTick(1) - this.getPixelForTick(0) - 6; u > d && r < e.maxRotation;) { var c = o.toRadians(r); if (l = Math.cos(c), Math.sin(c) * h > this.maxHeight) { r--; break } r++ , u = l * h } this.labelRotation = r }, afterCalculateTickRotation: function () { o.callback(this.options.afterCalculateTickRotation, [this]) }, beforeFit: function () { o.callback(this.options.beforeFit, [this]) }, fit: function () { var t = this.minSize = { width: 0, height: 0 }, n = s(this._ticks), a = this.options, l = a.ticks, h = a.scaleLabel, u = a.gridLines, d = a.display, c = this.isHorizontal(), f = i(l), g = a.gridLines.tickMarkLength; if (t.width = c ? this.isFullWidth() ? this.maxWidth - this.margins.left - this.margins.right : this.maxWidth : d && u.drawTicks ? g : 0, t.height = c ? d && u.drawTicks ? g : 0 : this.maxHeight, h.display && d) { var p = r(h) + o.options.toPadding(h.padding).height; c ? t.height += p : t.width += p } if (l.display && d) { var v = o.longestText(this.ctx, f.font, n, this.longestTextCache), m = o.numberOfLabelLines(n), b = .5 * f.size, x = this.options.ticks.padding; if (c) { this.longestLabelWidth = v; var y = o.toRadians(this.labelRotation), k = Math.cos(y), w = Math.sin(y) * v + f.size * m + b * (m - 1) + b; t.height = Math.min(this.maxHeight, t.height + w + x), this.ctx.font = f.font; var M = e(this.ctx, n[0], f.font), S = e(this.ctx, n[n.length - 1], f.font); 0 !== this.labelRotation ? (this.paddingLeft = "bottom" === a.position ? k * M + 3 : k * b + 3, this.paddingRight = "bottom" === a.position ? k * b + 3 : k * S + 3) : (this.paddingLeft = M / 2 + 3, this.paddingRight = S / 2 + 3) } else l.mirror ? v = 0 : v += x + b, t.width = Math.min(this.maxWidth, t.width + v), this.paddingTop = f.size / 2, this.paddingBottom = f.size / 2 } this.handleMargins(), this.width = t.width, this.height = t.height }, handleMargins: function () { this.margins && (this.paddingLeft = Math.max(this.paddingLeft - this.margins.left, 0), this.paddingTop = Math.max(this.paddingTop - this.margins.top, 0), this.paddingRight = Math.max(this.paddingRight - this.margins.right, 0), this.paddingBottom = Math.max(this.paddingBottom - this.margins.bottom, 0)) }, afterFit: function () { o.callback(this.options.afterFit, [this]) }, isHorizontal: function () { return "top" === this.options.position || "bottom" === this.options.position }, isFullWidth: function () { return this.options.fullWidth }, getRightValue: function (t) { if (o.isNullOrUndef(t)) return NaN; if ("number" == typeof t && !isFinite(t)) return NaN; if (t) if (this.isHorizontal()) { if (void 0 !== t.x) return this.getRightValue(t.x) } else if (void 0 !== t.y) return this.getRightValue(t.y); return t }, getLabelForIndex: o.noop, getPixelForValue: o.noop, getValueForPixel: o.noop, getPixelForTick: function (t) { var e = this.options.offset; if (this.isHorizontal()) { var i = (this.width - (this.paddingLeft + this.paddingRight)) / Math.max(this._ticks.length - (e ? 0 : 1), 1), n = i * t + this.paddingLeft; e && (n += i / 2); var a = this.left + Math.round(n); return a += this.isFullWidth() ? this.margins.left : 0 } var o = this.height - (this.paddingTop + this.paddingBottom); return this.top + t * (o / (this._ticks.length - 1)) }, getPixelForDecimal: function (t) { if (this.isHorizontal()) { var e = (this.width - (this.paddingLeft + this.paddingRight)) * t + this.paddingLeft, i = this.left + Math.round(e); return i += this.isFullWidth() ? this.margins.left : 0 } return this.top + t * this.height }, getBasePixel: function () { return this.getPixelForValue(this.getBaseValue()) }, getBaseValue: function () { var t = this.min, e = this.max; return this.beginAtZero ? 0 : t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0 }, _autoSkip: function (t) { var e, i, n, a, r = this.isHorizontal(), s = this.options.ticks.minor, l = t.length, h = o.toRadians(this.labelRotation), u = Math.cos(h), d = this.longestLabelWidth * u, c = []; for (s.maxTicksLimit && (a = s.maxTicksLimit), r && (e = !1, (d + s.autoSkipPadding) * l > this.width - (this.paddingLeft + this.paddingRight) && (e = 1 + Math.floor((d + s.autoSkipPadding) * l / (this.width - (this.paddingLeft + this.paddingRight)))), a && l > a && (e = Math.max(e, Math.floor(l / a)))), i = 0; i < l; i++)n = t[i], (e > 1 && i % e > 0 || i % e == 0 && i + e >= l) && i !== l - 1 && delete n.label, c.push(n); return c }, draw: function (t) { var e = this, a = e.options; if (a.display) { var s = e.ctx, h = n.global, u = a.ticks.minor, d = a.ticks.major || u, c = a.gridLines, f = a.scaleLabel, g = 0 !== e.labelRotation, p = e.isHorizontal(), v = u.autoSkip ? e._autoSkip(e.getTicks()) : e.getTicks(), m = o.valueOrDefault(u.fontColor, h.defaultFontColor), b = i(u), x = o.valueOrDefault(d.fontColor, h.defaultFontColor), y = i(d), k = c.drawTicks ? c.tickMarkLength : 0, w = o.valueOrDefault(f.fontColor, h.defaultFontColor), M = i(f), S = o.options.toPadding(f.padding), C = o.toRadians(e.labelRotation), _ = [], D = "right" === a.position ? e.left : e.right - k, I = "right" === a.position ? e.left + k : e.right, P = "bottom" === a.position ? e.top : e.bottom - k, A = "bottom" === a.position ? e.top + k : e.bottom; if (o.each(v, function (i, n) { if (!o.isNullOrUndef(i.label)) { var r, s, d, f, m = i.label; n === e.zeroLineIndex && a.offset === c.offsetGridLines ? (r = c.zeroLineWidth, s = c.zeroLineColor, d = c.zeroLineBorderDash, f = c.zeroLineBorderDashOffset) : (r = o.valueAtIndexOrDefault(c.lineWidth, n), s = o.valueAtIndexOrDefault(c.color, n), d = o.valueOrDefault(c.borderDash, h.borderDash), f = o.valueOrDefault(c.borderDashOffset, h.borderDashOffset)); var b, x, y, w, M, S, T, F, O, R, L = "middle", z = "middle", B = u.padding; if (p) { var W = k + B; "bottom" === a.position ? (z = g ? "middle" : "top", L = g ? "right" : "center", R = e.top + W) : (z = g ? "middle" : "bottom", L = g ? "left" : "center", R = e.bottom - W); var N = l(e, n, c.offsetGridLines && v.length > 1); N < e.left && (s = "rgba(0,0,0,0)"), N += o.aliasPixel(r), O = e.getPixelForTick(n) + u.labelOffset, b = y = M = T = N, x = P, w = A, S = t.top, F = t.bottom } else { var V, E = "left" === a.position; u.mirror ? (L = E ? "left" : "right", V = B) : (L = E ? "right" : "left", V = k + B), O = E ? e.right - V : e.left + V; var H = l(e, n, c.offsetGridLines && v.length > 1); H < e.top && (s = "rgba(0,0,0,0)"), H += o.aliasPixel(r), R = e.getPixelForTick(n) + u.labelOffset, b = D, y = I, M = t.left, T = t.right, x = w = S = F = H } _.push({ tx1: b, ty1: x, tx2: y, ty2: w, x1: M, y1: S, x2: T, y2: F, labelX: O, labelY: R, glWidth: r, glColor: s, glBorderDash: d, glBorderDashOffset: f, rotation: -1 * C, label: m, major: i.major, textBaseline: z, textAlign: L }) } }), o.each(_, function (t) { if (c.display && (s.save(), s.lineWidth = t.glWidth, s.strokeStyle = t.glColor, s.setLineDash && (s.setLineDash(t.glBorderDash), s.lineDashOffset = t.glBorderDashOffset), s.beginPath(), c.drawTicks && (s.moveTo(t.tx1, t.ty1), s.lineTo(t.tx2, t.ty2)), c.drawOnChartArea && (s.moveTo(t.x1, t.y1), s.lineTo(t.x2, t.y2)), s.stroke(), s.restore()), u.display) { s.save(), s.translate(t.labelX, t.labelY), s.rotate(t.rotation), s.font = t.major ? y.font : b.font, s.fillStyle = t.major ? x : m, s.textBaseline = t.textBaseline, s.textAlign = t.textAlign; var e = t.label; if (o.isArray(e)) for (var i = 0, n = 0; i < e.length; ++i)s.fillText("" + e[i], 0, n), n += 1.5 * b.size; else s.fillText(e, 0, 0); s.restore() } }), f.display) { var T, F, O = 0, R = r(f) / 2; if (p) T = e.left + (e.right - e.left) / 2, F = "bottom" === a.position ? e.bottom - R - S.bottom : e.top + R + S.top; else { var L = "left" === a.position; T = L ? e.left + R + S.top : e.right - R - S.top, F = e.top + (e.bottom - e.top) / 2, O = L ? -.5 * Math.PI : .5 * Math.PI } s.save(), s.translate(T, F), s.rotate(O), s.textAlign = "center", s.textBaseline = "middle", s.fillStyle = w, s.font = M.font, s.fillText(f.labelString, 0, 0), s.restore() } if (c.drawBorder) { s.lineWidth = o.valueAtIndexOrDefault(c.lineWidth, 0), s.strokeStyle = o.valueAtIndexOrDefault(c.color, 0); var z = e.left, B = e.right, W = e.top, N = e.bottom, V = o.aliasPixel(s.lineWidth); p ? (W = N = "top" === a.position ? e.bottom : e.top, W += V, N += V) : (z = B = "left" === a.position ? e.right : e.left, z += V, B += V), s.beginPath(), s.moveTo(z, W), s.lineTo(B, N), s.stroke() } } } }) } }, { 25: 25, 26: 26, 34: 34, 45: 45 }], 33: [function (t, e, i) { "use strict"; var n = t(25), a = t(45); e.exports = function (t) { t.scaleService = { constructors: {}, defaults: {}, registerScaleType: function (t, e, i) { this.constructors[t] = e, this.defaults[t] = a.clone(i) }, getScaleConstructor: function (t) { return this.constructors.hasOwnProperty(t) ? this.constructors[t] : void 0 }, getScaleDefaults: function (t) { return this.defaults.hasOwnProperty(t) ? a.merge({}, [n.scale, this.defaults[t]]) : {} }, updateScaleDefaults: function (t, e) { this.defaults.hasOwnProperty(t) && (this.defaults[t] = a.extend(this.defaults[t], e)) }, addScalesToLayout: function (e) { a.each(e.scales, function (i) { i.fullWidth = i.options.fullWidth, i.position = i.options.position, i.weight = i.options.weight, t.layoutService.addBox(e, i) }) } } } }, { 25: 25, 45: 45 }], 34: [function (t, e, i) { "use strict"; var n = t(45); e.exports = { generators: { linear: function (t, e) { var i, a = []; if (t.stepSize && t.stepSize > 0) i = t.stepSize; else { var o = n.niceNum(e.max - e.min, !1); i = n.niceNum(o / (t.maxTicks - 1), !0) } var r = Math.floor(e.min / i) * i, s = Math.ceil(e.max / i) * i; t.min && t.max && t.stepSize && n.almostWhole((t.max - t.min) / t.stepSize, i / 1e3) && (r = t.min, s = t.max); var l = (s - r) / i; l = n.almostEquals(l, Math.round(l), i / 1e3) ? Math.round(l) : Math.ceil(l); var h = 1; i < 1 && (h = Math.pow(10, i.toString().length - 2), r = Math.round(r * h) / h, s = Math.round(s * h) / h), a.push(void 0 !== t.min ? t.min : r); for (var u = 1; u < l; ++u)a.push(Math.round((r + u * i) * h) / h); return a.push(void 0 !== t.max ? t.max : s), a }, logarithmic: function (t, e) { var i, a, o = [], r = n.valueOrDefault, s = r(t.min, Math.pow(10, Math.floor(n.log10(e.min)))), l = Math.floor(n.log10(e.max)), h = Math.ceil(e.max / Math.pow(10, l)); 0 === s ? (i = Math.floor(n.log10(e.minNotZero)), a = Math.floor(e.minNotZero / Math.pow(10, i)), o.push(s), s = a * Math.pow(10, i)) : (i = Math.floor(n.log10(s)), a = Math.floor(s / Math.pow(10, i))); var u = i < 0 ? Math.pow(10, Math.abs(i)) : 1; do { o.push(s), 10 === ++a && (a = 1, u = ++i >= 0 ? 1 : u), s = Math.round(a * Math.pow(10, i) * u) / u } while (i < l || i === l && a < h); var d = r(t.max, s); return o.push(d), o } }, formatters: { values: function (t) { return n.isArray(t) ? t : "" + t }, linear: function (t, e, i) { var a = i.length > 3 ? i[2] - i[1] : i[1] - i[0]; Math.abs(a) > 1 && t !== Math.floor(t) && (a = t - Math.floor(t)); var o = n.log10(Math.abs(a)), r = ""; if (0 !== t) { var s = -1 * Math.floor(o); s = Math.max(Math.min(s, 20), 0), r = t.toFixed(s) } else r = "0"; return r }, logarithmic: function (t, e, i) { var a = t / Math.pow(10, Math.floor(n.log10(t))); return 0 === t ? "0" : 1 === a || 2 === a || 5 === a || 0 === e || e === i.length - 1 ? t.toExponential() : "" } } } }, { 45: 45 }], 35: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45); n._set("global", { tooltips: { enabled: !0, custom: null, mode: "nearest", position: "average", intersect: !0, backgroundColor: "rgba(0,0,0,0.8)", titleFontStyle: "bold", titleSpacing: 2, titleMarginBottom: 6, titleFontColor: "#fff", titleAlign: "left", bodySpacing: 2, bodyFontColor: "#fff", bodyAlign: "left", footerFontStyle: "bold", footerSpacing: 2, footerMarginTop: 6, footerFontColor: "#fff", footerAlign: "left", yPadding: 6, xPadding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, multiKeyBackground: "#fff", displayColors: !0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, callbacks: { beforeTitle: o.noop, title: function (t, e) { var i = "", n = e.labels, a = n ? n.length : 0; if (t.length > 0) { var o = t[0]; o.xLabel ? i = o.xLabel : a > 0 && o.index < a && (i = n[o.index]) } return i }, afterTitle: o.noop, beforeBody: o.noop, beforeLabel: o.noop, label: function (t, e) { var i = e.datasets[t.datasetIndex].label || ""; return i && (i += ": "), i += t.yLabel }, labelColor: function (t, e) { var i = e.getDatasetMeta(t.datasetIndex).data[t.index]._view; return { borderColor: i.borderColor, backgroundColor: i.backgroundColor } }, labelTextColor: function () { return this._options.bodyFontColor }, afterLabel: o.noop, afterBody: o.noop, beforeFooter: o.noop, footer: o.noop, afterFooter: o.noop } } }), e.exports = function (t) { function e(t, e) { var i = o.color(t); return i.alpha(e * i.alpha()).rgbaString() } function i(t, e) { return e && (o.isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t } function r(t) { var e = t._xScale, i = t._yScale || t._scale, n = t._index, a = t._datasetIndex; return { xLabel: e ? e.getLabelForIndex(n, a) : "", yLabel: i ? i.getLabelForIndex(n, a) : "", index: n, datasetIndex: a, x: t._model.x, y: t._model.y } } function s(t) { var e = n.global, i = o.valueOrDefault; return { xPadding: t.xPadding, yPadding: t.yPadding, xAlign: t.xAlign, yAlign: t.yAlign, bodyFontColor: t.bodyFontColor, _bodyFontFamily: i(t.bodyFontFamily, e.defaultFontFamily), _bodyFontStyle: i(t.bodyFontStyle, e.defaultFontStyle), _bodyAlign: t.bodyAlign, bodyFontSize: i(t.bodyFontSize, e.defaultFontSize), bodySpacing: t.bodySpacing, titleFontColor: t.titleFontColor, _titleFontFamily: i(t.titleFontFamily, e.defaultFontFamily), _titleFontStyle: i(t.titleFontStyle, e.defaultFontStyle), titleFontSize: i(t.titleFontSize, e.defaultFontSize), _titleAlign: t.titleAlign, titleSpacing: t.titleSpacing, titleMarginBottom: t.titleMarginBottom, footerFontColor: t.footerFontColor, _footerFontFamily: i(t.footerFontFamily, e.defaultFontFamily), _footerFontStyle: i(t.footerFontStyle, e.defaultFontStyle), footerFontSize: i(t.footerFontSize, e.defaultFontSize), _footerAlign: t.footerAlign, footerSpacing: t.footerSpacing, footerMarginTop: t.footerMarginTop, caretSize: t.caretSize, cornerRadius: t.cornerRadius, backgroundColor: t.backgroundColor, opacity: 0, legendColorBackground: t.multiKeyBackground, displayColors: t.displayColors, borderColor: t.borderColor, borderWidth: t.borderWidth } } t.Tooltip = a.extend({ initialize: function () { this._model = s(this._options), this._lastActive = [] }, getTitle: function () { var t = this._options.callbacks, e = t.beforeTitle.apply(this, arguments), n = t.title.apply(this, arguments), a = t.afterTitle.apply(this, arguments), o = []; return o = i(o = i(o = i(o, e), n), a) }, getBeforeBody: function () { var t = this._options.callbacks.beforeBody.apply(this, arguments); return o.isArray(t) ? t : void 0 !== t ? [t] : [] }, getBody: function (t, e) { var n = this, a = n._options.callbacks, r = []; return o.each(t, function (t) { var o = { before: [], lines: [], after: [] }; i(o.before, a.beforeLabel.call(n, t, e)), i(o.lines, a.label.call(n, t, e)), i(o.after, a.afterLabel.call(n, t, e)), r.push(o) }), r }, getAfterBody: function () { var t = this._options.callbacks.afterBody.apply(this, arguments); return o.isArray(t) ? t : void 0 !== t ? [t] : [] }, getFooter: function () { var t = this._options.callbacks, e = t.beforeFooter.apply(this, arguments), n = t.footer.apply(this, arguments), a = t.afterFooter.apply(this, arguments), o = []; return o = i(o = i(o = i(o, e), n), a) }, update: function (e) { var i, n, a = this, l = a._options, h = a._model, u = a._model = s(l), d = a._active, c = a._data, f = { xAlign: h.xAlign, yAlign: h.yAlign }, g = { x: h.x, y: h.y }, p = { width: h.width, height: h.height }, v = { x: h.caretX, y: h.caretY }; if (d.length) { u.opacity = 1; var m = [], b = []; v = t.Tooltip.positioners[l.position].call(a, d, a._eventPosition); var x = []; for (i = 0, n = d.length; i < n; ++i)x.push(r(d[i])); l.filter && (x = x.filter(function (t) { return l.filter(t, c) })), l.itemSort && (x = x.sort(function (t, e) { return l.itemSort(t, e, c) })), o.each(x, function (t) { m.push(l.callbacks.labelColor.call(a, t, a._chart)), b.push(l.callbacks.labelTextColor.call(a, t, a._chart)) }), u.title = a.getTitle(x, c), u.beforeBody = a.getBeforeBody(x, c), u.body = a.getBody(x, c), u.afterBody = a.getAfterBody(x, c), u.footer = a.getFooter(x, c), u.x = Math.round(v.x), u.y = Math.round(v.y), u.caretPadding = l.caretPadding, u.labelColors = m, u.labelTextColors = b, u.dataPoints = x, g = function (t, e, i, n) { var a = t.x, o = t.y, r = t.caretSize, s = t.caretPadding, l = t.cornerRadius, h = i.xAlign, u = i.yAlign, d = r + s, c = l + s; return "right" === h ? a -= e.width : "center" === h && ((a -= e.width / 2) + e.width > n.width && (a = n.width - e.width), a < 0 && (a = 0)), "top" === u ? o += d : o -= "bottom" === u ? e.height + d : e.height / 2, "center" === u ? "left" === h ? a += d : "right" === h && (a -= d) : "left" === h ? a -= c : "right" === h && (a += c), { x: a, y: o } }(u, p = function (t, e) { var i = t._chart.ctx, n = 2 * e.yPadding, a = 0, r = e.body, s = r.reduce(function (t, e) { return t + e.before.length + e.lines.length + e.after.length }, 0); s += e.beforeBody.length + e.afterBody.length; var l = e.title.length, h = e.footer.length, u = e.titleFontSize, d = e.bodyFontSize, c = e.footerFontSize; n += l * u, n += l ? (l - 1) * e.titleSpacing : 0, n += l ? e.titleMarginBottom : 0, n += s * d, n += s ? (s - 1) * e.bodySpacing : 0, n += h ? e.footerMarginTop : 0, n += h * c, n += h ? (h - 1) * e.footerSpacing : 0; var f = 0, g = function (t) { a = Math.max(a, i.measureText(t).width + f) }; return i.font = o.fontString(u, e._titleFontStyle, e._titleFontFamily), o.each(e.title, g), i.font = o.fontString(d, e._bodyFontStyle, e._bodyFontFamily), o.each(e.beforeBody.concat(e.afterBody), g), f = e.displayColors ? d + 2 : 0, o.each(r, function (t) { o.each(t.before, g), o.each(t.lines, g), o.each(t.after, g) }), f = 0, i.font = o.fontString(c, e._footerFontStyle, e._footerFontFamily), o.each(e.footer, g), { width: a += 2 * e.xPadding, height: n } }(this, u), f = function (t, e) { var i = t._model, n = t._chart, a = t._chart.chartArea, o = "center", r = "center"; i.y < e.height ? r = "top" : i.y > n.height - e.height && (r = "bottom"); var s, l, h, u, d, c = (a.left + a.right) / 2, f = (a.top + a.bottom) / 2; "center" === r ? (s = function (t) { return t <= c }, l = function (t) { return t > c }) : (s = function (t) { return t <= e.width / 2 }, l = function (t) { return t >= n.width - e.width / 2 }), h = function (t) { return t + e.width + i.caretSize + i.caretPadding > n.width }, u = function (t) { return t - e.width - i.caretSize - i.caretPadding < 0 }, d = function (t) { return t <= f ? "top" : "bottom" }, s(i.x) ? (o = "left", h(i.x) && (o = "center", r = d(i.y))) : l(i.x) && (o = "right", u(i.x) && (o = "center", r = d(i.y))); var g = t._options; return { xAlign: g.xAlign ? g.xAlign : o, yAlign: g.yAlign ? g.yAlign : r } }(this, p), a._chart) } else u.opacity = 0; return u.xAlign = f.xAlign, u.yAlign = f.yAlign, u.x = g.x, u.y = g.y, u.width = p.width, u.height = p.height, u.caretX = v.x, u.caretY = v.y, a._model = u, e && l.custom && l.custom.call(a, u), a }, drawCaret: function (t, e) { var i = this._chart.ctx, n = this._view, a = this.getCaretPosition(t, e, n); i.lineTo(a.x1, a.y1), i.lineTo(a.x2, a.y2), i.lineTo(a.x3, a.y3) }, getCaretPosition: function (t, e, i) { var n, a, o, r, s, l, h = i.caretSize, u = i.cornerRadius, d = i.xAlign, c = i.yAlign, f = t.x, g = t.y, p = e.width, v = e.height; if ("center" === c) s = g + v / 2, "left" === d ? (a = (n = f) - h, o = n, r = s + h, l = s - h) : (a = (n = f + p) + h, o = n, r = s - h, l = s + h); else if ("left" === d ? (n = (a = f + u + h) - h, o = a + h) : "right" === d ? (n = (a = f + p - u - h) - h, o = a + h) : (n = (a = i.caretX) - h, o = a + h), "top" === c) s = (r = g) - h, l = r; else { s = (r = g + v) + h, l = r; var m = o; o = n, n = m } return { x1: n, x2: a, x3: o, y1: r, y2: s, y3: l } }, drawTitle: function (t, i, n, a) { var r = i.title; if (r.length) { n.textAlign = i._titleAlign, n.textBaseline = "top"; var s = i.titleFontSize, l = i.titleSpacing; n.fillStyle = e(i.titleFontColor, a), n.font = o.fontString(s, i._titleFontStyle, i._titleFontFamily); var h, u; for (h = 0, u = r.length; h < u; ++h)n.fillText(r[h], t.x, t.y), t.y += s + l, h + 1 === r.length && (t.y += i.titleMarginBottom - l) } }, drawBody: function (t, i, n, a) { var r = i.bodyFontSize, s = i.bodySpacing, l = i.body; n.textAlign = i._bodyAlign, n.textBaseline = "top", n.font = o.fontString(r, i._bodyFontStyle, i._bodyFontFamily); var h = 0, u = function (e) { n.fillText(e, t.x + h, t.y), t.y += r + s }; n.fillStyle = e(i.bodyFontColor, a), o.each(i.beforeBody, u); var d = i.displayColors; h = d ? r + 2 : 0, o.each(l, function (s, l) { var h = e(i.labelTextColors[l], a); n.fillStyle = h, o.each(s.before, u), o.each(s.lines, function (o) { d && (n.fillStyle = e(i.legendColorBackground, a), n.fillRect(t.x, t.y, r, r), n.lineWidth = 1, n.strokeStyle = e(i.labelColors[l].borderColor, a), n.strokeRect(t.x, t.y, r, r), n.fillStyle = e(i.labelColors[l].backgroundColor, a), n.fillRect(t.x + 1, t.y + 1, r - 2, r - 2), n.fillStyle = h), u(o) }), o.each(s.after, u) }), h = 0, o.each(i.afterBody, u), t.y -= s }, drawFooter: function (t, i, n, a) { var r = i.footer; r.length && (t.y += i.footerMarginTop, n.textAlign = i._footerAlign, n.textBaseline = "top", n.fillStyle = e(i.footerFontColor, a), n.font = o.fontString(i.footerFontSize, i._footerFontStyle, i._footerFontFamily), o.each(r, function (e) { n.fillText(e, t.x, t.y), t.y += i.footerFontSize + i.footerSpacing })) }, drawBackground: function (t, i, n, a, o) { n.fillStyle = e(i.backgroundColor, o), n.strokeStyle = e(i.borderColor, o), n.lineWidth = i.borderWidth; var r = i.xAlign, s = i.yAlign, l = t.x, h = t.y, u = a.width, d = a.height, c = i.cornerRadius; n.beginPath(), n.moveTo(l + c, h), "top" === s && this.drawCaret(t, a), n.lineTo(l + u - c, h), n.quadraticCurveTo(l + u, h, l + u, h + c), "center" === s && "right" === r && this.drawCaret(t, a), n.lineTo(l + u, h + d - c), n.quadraticCurveTo(l + u, h + d, l + u - c, h + d), "bottom" === s && this.drawCaret(t, a), n.lineTo(l + c, h + d), n.quadraticCurveTo(l, h + d, l, h + d - c), "center" === s && "left" === r && this.drawCaret(t, a), n.lineTo(l, h + c), n.quadraticCurveTo(l, h, l + c, h), n.closePath(), n.fill(), i.borderWidth > 0 && n.stroke() }, draw: function () { var t = this._chart.ctx, e = this._view; if (0 !== e.opacity) { var i = { width: e.width, height: e.height }, n = { x: e.x, y: e.y }, a = Math.abs(e.opacity < .001) ? 0 : e.opacity, o = e.title.length || e.beforeBody.length || e.body.length || e.afterBody.length || e.footer.length; this._options.enabled && o && (this.drawBackground(n, e, t, i, a), n.x += e.xPadding, n.y += e.yPadding, this.drawTitle(n, e, t, a), this.drawBody(n, e, t, a), this.drawFooter(n, e, t, a)) } }, handleEvent: function (t) { var e = this._options, i = !1; return this._lastActive = this._lastActive || [], "mouseout" === t.type ? this._active = [] : this._active = this._chart.getElementsAtEventForMode(t, e.mode, e), (i = !o.arrayEquals(this._active, this._lastActive)) && (this._lastActive = this._active, (e.enabled || e.custom) && (this._eventPosition = { x: t.x, y: t.y }, this.update(!0), this.pivot())), i } }), t.Tooltip.positioners = { average: function (t) { if (!t.length) return !1; var e, i, n = 0, a = 0, o = 0; for (e = 0, i = t.length; e < i; ++e) { var r = t[e]; if (r && r.hasValue()) { var s = r.tooltipPosition(); n += s.x, a += s.y, ++o } } return { x: Math.round(n / o), y: Math.round(a / o) } }, nearest: function (t, e) { var i, n, a, r = e.x, s = e.y, l = Number.POSITIVE_INFINITY; for (i = 0, n = t.length; i < n; ++i) { var h = t[i]; if (h && h.hasValue()) { var u = h.getCenterPoint(), d = o.distanceBetweenPoints(e, u); d < l && (l = d, a = h) } } if (a) { var c = a.tooltipPosition(); r = c.x, s = c.y } return { x: r, y: s } } } } }, { 25: 25, 26: 26, 45: 45 }], 36: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45); n._set("global", { elements: { arc: { backgroundColor: n.global.defaultColor, borderColor: "#fff", borderWidth: 2 } } }), e.exports = a.extend({ inLabelRange: function (t) { var e = this._view; return !!e && Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hoverRadius, 2) }, inRange: function (t, e) { var i = this._view; if (i) { for (var n = o.getAngleFromPoint(i, { x: t, y: e }), a = n.angle, r = n.distance, s = i.startAngle, l = i.endAngle; l < s;)l += 2 * Math.PI; for (; a > l;)a -= 2 * Math.PI; for (; a < s;)a += 2 * Math.PI; var h = a >= s && a <= l, u = r >= i.innerRadius && r <= i.outerRadius; return h && u } return !1 }, getCenterPoint: function () { var t = this._view, e = (t.startAngle + t.endAngle) / 2, i = (t.innerRadius + t.outerRadius) / 2; return { x: t.x + Math.cos(e) * i, y: t.y + Math.sin(e) * i } }, getArea: function () { var t = this._view; return Math.PI * ((t.endAngle - t.startAngle) / (2 * Math.PI)) * (Math.pow(t.outerRadius, 2) - Math.pow(t.innerRadius, 2)) }, tooltipPosition: function () { var t = this._view, e = t.startAngle + (t.endAngle - t.startAngle) / 2, i = (t.outerRadius - t.innerRadius) / 2 + t.innerRadius; return { x: t.x + Math.cos(e) * i, y: t.y + Math.sin(e) * i } }, draw: function () { var t = this._chart.ctx, e = this._view, i = e.startAngle, n = e.endAngle; t.beginPath(), t.arc(e.x, e.y, e.outerRadius, i, n), t.arc(e.x, e.y, e.innerRadius, n, i, !0), t.closePath(), t.strokeStyle = e.borderColor, t.lineWidth = e.borderWidth, t.fillStyle = e.backgroundColor, t.fill(), t.lineJoin = "bevel", e.borderWidth && t.stroke() } }) }, { 25: 25, 26: 26, 45: 45 }], 37: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45), r = n.global; n._set("global", { elements: { line: { tension: .4, backgroundColor: r.defaultColor, borderWidth: 3, borderColor: r.defaultColor, borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", capBezierPoints: !0, fill: !0 } } }), e.exports = a.extend({ draw: function () { var t, e, i, n, a = this._view, s = this._chart.ctx, l = a.spanGaps, h = this._children.slice(), u = r.elements.line, d = -1; for (this._loop && h.length && h.push(h[0]), s.save(), s.lineCap = a.borderCapStyle || u.borderCapStyle, s.setLineDash && s.setLineDash(a.borderDash || u.borderDash), s.lineDashOffset = a.borderDashOffset || u.borderDashOffset, s.lineJoin = a.borderJoinStyle || u.borderJoinStyle, s.lineWidth = a.borderWidth || u.borderWidth, s.strokeStyle = a.borderColor || r.defaultColor, s.beginPath(), d = -1, t = 0; t < h.length; ++t)e = h[t], i = o.previousItem(h, t), n = e._view, 0 === t ? n.skip || (s.moveTo(n.x, n.y), d = t) : (i = -1 === d ? i : h[d], n.skip || (d !== t - 1 && !l || -1 === d ? s.moveTo(n.x, n.y) : o.canvas.lineTo(s, i._view, e._view), d = t)); s.stroke(), s.restore() } }) }, { 25: 25, 26: 26, 45: 45 }], 38: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45), r = n.global.defaultColor; n._set("global", { elements: { point: { radius: 3, pointStyle: "circle", backgroundColor: r, borderColor: r, borderWidth: 1, hitRadius: 1, hoverRadius: 4, hoverBorderWidth: 1 } } }); function s(t) { var e = this._view; return !!e && Math.abs(t - e.x) < e.radius + e.hitRadius } e.exports = a.extend({ inRange: function (t, e) { var i = this._view; return !!i && Math.pow(t - i.x, 2) + Math.pow(e - i.y, 2) < Math.pow(i.hitRadius + i.radius, 2) }, inLabelRange: s, inXRange: s, inYRange: function (t) { var e = this._view; return !!e && Math.abs(t - e.y) < e.radius + e.hitRadius }, getCenterPoint: function () { var t = this._view; return { x: t.x, y: t.y } }, getArea: function () { return Math.PI * Math.pow(this._view.radius, 2) }, tooltipPosition: function () { var t = this._view; return { x: t.x, y: t.y, padding: t.radius + t.borderWidth } }, draw: function (t) { var e = this._view, i = this._model, a = this._chart.ctx, s = e.pointStyle, l = e.radius, h = e.x, u = e.y, d = o.color, c = 0; e.skip || (a.strokeStyle = e.borderColor || r, a.lineWidth = o.valueOrDefault(e.borderWidth, n.global.elements.point.borderWidth), a.fillStyle = e.backgroundColor || r, void 0 !== t && (i.x < t.left || 1.01 * t.right < i.x || i.y < t.top || 1.01 * t.bottom < i.y) && (i.x < t.left ? c = (h - i.x) / (t.left - i.x) : 1.01 * t.right < i.x ? c = (i.x - h) / (i.x - t.right) : i.y < t.top ? c = (u - i.y) / (t.top - i.y) : 1.01 * t.bottom < i.y && (c = (i.y - u) / (i.y - t.bottom)), c = Math.round(100 * c) / 100, a.strokeStyle = d(a.strokeStyle).alpha(c).rgbString(), a.fillStyle = d(a.fillStyle).alpha(c).rgbString()), o.canvas.drawPoint(a, s, l, h, u)) } }) }, { 25: 25, 26: 26, 45: 45 }], 39: [function (t, e, i) { "use strict"; var n = t(25), a = t(26); n._set("global", { elements: { rectangle: { backgroundColor: n.global.defaultColor, borderColor: n.global.defaultColor, borderSkipped: "bottom", borderWidth: 0 } } }); function o(t) { return void 0 !== t._view.width } function r(t) { var e, i, n, a, r = t._view; if (o(t)) { var s = r.width / 2; e = r.x - s, i = r.x + s, n = Math.min(r.y, r.base), a = Math.max(r.y, r.base) } else { var l = r.height / 2; e = Math.min(r.x, r.base), i = Math.max(r.x, r.base), n = r.y - l, a = r.y + l } return { left: e, top: n, right: i, bottom: a } } e.exports = a.extend({ draw: function () { var t, e, i, n, a, o, r, s = this._chart.ctx, l = this._view, h = l.borderWidth; if (l.horizontal ? (t = l.base, e = l.x, i = l.y - l.height / 2, n = l.y + l.height / 2, a = e > t ? 1 : -1, o = 1, r = l.borderSkipped || "left") : (t = l.x - l.width / 2, e = l.x + l.width / 2, i = l.y, a = 1, o = (n = l.base) > i ? 1 : -1, r = l.borderSkipped || "bottom"), h) { var u = Math.min(Math.abs(t - e), Math.abs(i - n)), d = (h = h > u ? u : h) / 2, c = t + ("left" !== r ? d * a : 0), f = e + ("right" !== r ? -d * a : 0), g = i + ("top" !== r ? d * o : 0), p = n + ("bottom" !== r ? -d * o : 0); c !== f && (i = g, n = p), g !== p && (t = c, e = f) } s.beginPath(), s.fillStyle = l.backgroundColor, s.strokeStyle = l.borderColor, s.lineWidth = h; var v = [[t, n], [t, i], [e, i], [e, n]], m = ["bottom", "left", "top", "right"].indexOf(r, 0); -1 === m && (m = 0); function b(t) { return v[(m + t) % 4] } var x = b(0); s.moveTo(x[0], x[1]); for (var y = 1; y < 4; y++)x = b(y), s.lineTo(x[0], x[1]); s.fill(), h && s.stroke() }, height: function () { var t = this._view; return t.base - t.y }, inRange: function (t, e) { var i = !1; if (this._view) { var n = r(this); i = t >= n.left && t <= n.right && e >= n.top && e <= n.bottom } return i }, inLabelRange: function (t, e) { if (!this._view) return !1; var i = r(this); return o(this) ? t >= i.left && t <= i.right : e >= i.top && e <= i.bottom }, inXRange: function (t) { var e = r(this); return t >= e.left && t <= e.right }, inYRange: function (t) { var e = r(this); return t >= e.top && t <= e.bottom }, getCenterPoint: function () { var t, e, i = this._view; return o(this) ? (t = i.x, e = (i.y + i.base) / 2) : (t = (i.x + i.base) / 2, e = i.y), { x: t, y: e } }, getArea: function () { var t = this._view; return t.width * Math.abs(t.y - t.base) }, tooltipPosition: function () { var t = this._view; return { x: t.x, y: t.y } } }) }, { 25: 25, 26: 26 }], 40: [function (t, e, i) { "use strict"; e.exports = {}, e.exports.Arc = t(36), e.exports.Line = t(37), e.exports.Point = t(38), e.exports.Rectangle = t(39) }, { 36: 36, 37: 37, 38: 38, 39: 39 }], 41: [function (t, e, i) { "use strict"; var n = t(42); i = e.exports = { clear: function (t) { t.ctx.clearRect(0, 0, t.width, t.height) }, roundedRect: function (t, e, i, n, a, o) { if (o) { var r = Math.min(o, n / 2), s = Math.min(o, a / 2); t.moveTo(e + r, i), t.lineTo(e + n - r, i), t.quadraticCurveTo(e + n, i, e + n, i + s), t.lineTo(e + n, i + a - s), t.quadraticCurveTo(e + n, i + a, e + n - r, i + a), t.lineTo(e + r, i + a), t.quadraticCurveTo(e, i + a, e, i + a - s), t.lineTo(e, i + s), t.quadraticCurveTo(e, i, e + r, i) } else t.rect(e, i, n, a) }, drawPoint: function (t, e, i, n, a) { var o, r, s, l, h, u; if (!e || "object" != typeof e || "[object HTMLImageElement]" !== (o = e.toString()) && "[object HTMLCanvasElement]" !== o) { if (!(isNaN(i) || i <= 0)) { switch (e) { default: t.beginPath(), t.arc(n, a, i, 0, 2 * Math.PI), t.closePath(), t.fill(); break; case "triangle": t.beginPath(), h = (r = 3 * i / Math.sqrt(3)) * Math.sqrt(3) / 2, t.moveTo(n - r / 2, a + h / 3), t.lineTo(n + r / 2, a + h / 3), t.lineTo(n, a - 2 * h / 3), t.closePath(), t.fill(); break; case "rect": u = 1 / Math.SQRT2 * i, t.beginPath(), t.fillRect(n - u, a - u, 2 * u, 2 * u), t.strokeRect(n - u, a - u, 2 * u, 2 * u); break; case "rectRounded": var d = i / Math.SQRT2, c = n - d, f = a - d, g = Math.SQRT2 * i; t.beginPath(), this.roundedRect(t, c, f, g, g, i / 2), t.closePath(), t.fill(); break; case "rectRot": u = 1 / Math.SQRT2 * i, t.beginPath(), t.moveTo(n - u, a), t.lineTo(n, a + u), t.lineTo(n + u, a), t.lineTo(n, a - u), t.closePath(), t.fill(); break; case "cross": t.beginPath(), t.moveTo(n, a + i), t.lineTo(n, a - i), t.moveTo(n - i, a), t.lineTo(n + i, a), t.closePath(); break; case "crossRot": t.beginPath(), s = Math.cos(Math.PI / 4) * i, l = Math.sin(Math.PI / 4) * i, t.moveTo(n - s, a - l), t.lineTo(n + s, a + l), t.moveTo(n - s, a + l), t.lineTo(n + s, a - l), t.closePath(); break; case "star": t.beginPath(), t.moveTo(n, a + i), t.lineTo(n, a - i), t.moveTo(n - i, a), t.lineTo(n + i, a), s = Math.cos(Math.PI / 4) * i, l = Math.sin(Math.PI / 4) * i, t.moveTo(n - s, a - l), t.lineTo(n + s, a + l), t.moveTo(n - s, a + l), t.lineTo(n + s, a - l), t.closePath(); break; case "line": t.beginPath(), t.moveTo(n - i, a), t.lineTo(n + i, a), t.closePath(); break; case "dash": t.beginPath(), t.moveTo(n, a), t.lineTo(n + i, a), t.closePath() }t.stroke() } } else t.drawImage(e, n - e.width / 2, a - e.height / 2, e.width, e.height) }, clipArea: function (t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip() }, unclipArea: function (t) { t.restore() }, lineTo: function (t, e, i, n) { if (i.steppedLine) return "after" === i.steppedLine && !n || "after" !== i.steppedLine && n ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y), void t.lineTo(i.x, i.y); i.tension ? t.bezierCurveTo(n ? e.controlPointPreviousX : e.controlPointNextX, n ? e.controlPointPreviousY : e.controlPointNextY, n ? i.controlPointNextX : i.controlPointPreviousX, n ? i.controlPointNextY : i.controlPointPreviousY, i.x, i.y) : t.lineTo(i.x, i.y) } }; n.clear = i.clear, n.drawRoundedRectangle = function (t) { t.beginPath(), i.roundedRect.apply(i, arguments), t.closePath() } }, { 42: 42 }], 42: [function (t, e, i) { "use strict"; var n = { noop: function () { }, uid: function () { var t = 0; return function () { return t++ } }(), isNullOrUndef: function (t) { return null === t || void 0 === t }, isArray: Array.isArray ? Array.isArray : function (t) { return "[object Array]" === Object.prototype.toString.call(t) }, isObject: function (t) { return null !== t && "[object Object]" === Object.prototype.toString.call(t) }, valueOrDefault: function (t, e) { return void 0 === t ? e : t }, valueAtIndexOrDefault: function (t, e, i) { return n.valueOrDefault(n.isArray(t) ? t[e] : t, i) }, callback: function (t, e, i) { if (t && "function" == typeof t.call) return t.apply(i, e) }, each: function (t, e, i, a) { var o, r, s; if (n.isArray(t)) if (r = t.length, a) for (o = r - 1; o >= 0; o--)e.call(i, t[o], o); else for (o = 0; o < r; o++)e.call(i, t[o], o); else if (n.isObject(t)) for (r = (s = Object.keys(t)).length, o = 0; o < r; o++)e.call(i, t[s[o]], s[o]) }, arrayEquals: function (t, e) { var i, a, o, r; if (!t || !e || t.length !== e.length) return !1; for (i = 0, a = t.length; i < a; ++i)if (o = t[i], r = e[i], o instanceof Array && r instanceof Array) { if (!n.arrayEquals(o, r)) return !1 } else if (o !== r) return !1; return !0 }, clone: function (t) { if (n.isArray(t)) return t.map(n.clone); if (n.isObject(t)) { for (var e = {}, i = Object.keys(t), a = i.length, o = 0; o < a; ++o)e[i[o]] = n.clone(t[i[o]]); return e } return t }, _merger: function (t, e, i, a) { var o = e[t], r = i[t]; n.isObject(o) && n.isObject(r) ? n.merge(o, r, a) : e[t] = n.clone(r) }, _mergerIf: function (t, e, i) { var a = e[t], o = i[t]; n.isObject(a) && n.isObject(o) ? n.mergeIf(a, o) : e.hasOwnProperty(t) || (e[t] = n.clone(o)) }, merge: function (t, e, i) { var a, o, r, s, l, h = n.isArray(e) ? e : [e], u = h.length; if (!n.isObject(t)) return t; for (a = (i = i || {}).merger || n._merger, o = 0; o < u; ++o)if (e = h[o], n.isObject(e)) for (l = 0, s = (r = Object.keys(e)).length; l < s; ++l)a(r[l], t, e, i); return t }, mergeIf: function (t, e) { return n.merge(t, e, { merger: n._mergerIf }) }, extend: function (t) { for (var e = function (e, i) { t[i] = e }, i = 1, a = arguments.length; i < a; ++i)n.each(arguments[i], e); return t }, inherits: function (t) { var e = this, i = t && t.hasOwnProperty("constructor") ? t.constructor : function () { return e.apply(this, arguments) }, a = function () { this.constructor = i }; return a.prototype = e.prototype, i.prototype = new a, i.extend = n.inherits, t && n.extend(i.prototype, t), i.__super__ = e.prototype, i } }; e.exports = n, n.callCallback = n.callback, n.indexOf = function (t, e, i) { return Array.prototype.indexOf.call(t, e, i) }, n.getValueOrDefault = n.valueOrDefault, n.getValueAtIndexOrDefault = n.valueAtIndexOrDefault }, {}], 43: [function (t, e, i) { "use strict"; var n = t(42), a = { linear: function (t) { return t }, easeInQuad: function (t) { return t * t }, easeOutQuad: function (t) { return -t * (t - 2) }, easeInOutQuad: function (t) { return (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1) }, easeInCubic: function (t) { return t * t * t }, easeOutCubic: function (t) { return (t -= 1) * t * t + 1 }, easeInOutCubic: function (t) { return (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2) }, easeInQuart: function (t) { return t * t * t * t }, easeOutQuart: function (t) { return -((t -= 1) * t * t * t - 1) }, easeInOutQuart: function (t) { return (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2) }, easeInQuint: function (t) { return t * t * t * t * t }, easeOutQuint: function (t) { return (t -= 1) * t * t * t * t + 1 }, easeInOutQuint: function (t) { return (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2) }, easeInSine: function (t) { return 1 - Math.cos(t * (Math.PI / 2)) }, easeOutSine: function (t) { return Math.sin(t * (Math.PI / 2)) }, easeInOutSine: function (t) { return -.5 * (Math.cos(Math.PI * t) - 1) }, easeInExpo: function (t) { return 0 === t ? 0 : Math.pow(2, 10 * (t - 1)) }, easeOutExpo: function (t) { return 1 === t ? 1 : 1 - Math.pow(2, -10 * t) }, easeInOutExpo: function (t) { return 0 === t ? 0 : 1 === t ? 1 : (t /= .5) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * --t)) }, easeInCirc: function (t) { return t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1) }, easeOutCirc: function (t) { return Math.sqrt(1 - (t -= 1) * t) }, easeInOutCirc: function (t) { return (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1) }, easeInElastic: function (t) { var e = 1.70158, i = 0, n = 1; return 0 === t ? 0 : 1 === t ? 1 : (i || (i = .3), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), -n * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i)) }, easeOutElastic: function (t) { var e = 1.70158, i = 0, n = 1; return 0 === t ? 0 : 1 === t ? 1 : (i || (i = .3), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), n * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / i) + 1) }, easeInOutElastic: function (t) { var e = 1.70158, i = 0, n = 1; return 0 === t ? 0 : 2 == (t /= .5) ? 1 : (i || (i = .45), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), t < 1 ? n * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i) * -.5 : n * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i) * .5 + 1) }, easeInBack: function (t) { return t * t * (2.70158 * t - 1.70158) }, easeOutBack: function (t) { return (t -= 1) * t * (2.70158 * t + 1.70158) + 1 }, easeInOutBack: function (t) { var e = 1.70158; return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2) }, easeInBounce: function (t) { return 1 - a.easeOutBounce(1 - t) }, easeOutBounce: function (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }, easeInOutBounce: function (t) { return t < .5 ? .5 * a.easeInBounce(2 * t) : .5 * a.easeOutBounce(2 * t - 1) + .5 } }; e.exports = { effects: a }, n.easingEffects = a }, { 42: 42 }], 44: [function (t, e, i) { "use strict"; var n = t(42); e.exports = { toLineHeight: function (t, e) { var i = ("" + t).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/); if (!i || "normal" === i[1]) return 1.2 * e; switch (t = +i[2], i[3]) { case "px": return t; case "%": t /= 100 }return e * t }, toPadding: function (t) { var e, i, a, o; return n.isObject(t) ? (e = +t.top || 0, i = +t.right || 0, a = +t.bottom || 0, o = +t.left || 0) : e = i = a = o = +t || 0, { top: e, right: i, bottom: a, left: o, height: e + a, width: o + i } }, resolve: function (t, e, i) { var a, o, r; for (a = 0, o = t.length; a < o; ++a)if (void 0 !== (r = t[a]) && (void 0 !== e && "function" == typeof r && (r = r(e)), void 0 !== i && n.isArray(r) && (r = r[i]), void 0 !== r)) return r } } }, { 42: 42 }], 45: [function (t, e, i) { "use strict"; e.exports = t(42), e.exports.easing = t(43), e.exports.canvas = t(41), e.exports.options = t(44) }, { 41: 41, 42: 42, 43: 43, 44: 44 }], 46: [function (t, e, i) { e.exports = { acquireContext: function (t) { return t && t.canvas && (t = t.canvas), t && t.getContext("2d") || null } } }, {}], 47: [function (t, e, i) { "use strict"; var n = t(45), a = "$chartjs", o = "chartjs-", r = o + "render-monitor", s = o + "render-animation", l = ["animationstart", "webkitAnimationStart"], h = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }; function u(t, e) { var i = n.getStyle(t, e), a = i && i.match(/^(\d+)(\.\d+)?px$/); return a ? Number(a[1]) : void 0 } var d = !!function () { var t = !1; try { var e = Object.defineProperty({}, "passive", { get: function () { t = !0 } }); window.addEventListener("e", null, e) } catch (t) { } return t }() && { passive: !0 }; function c(t, e, i) { t.addEventListener(e, i, d) } function f(t, e, i) { t.removeEventListener(e, i, d) } function g(t, e, i, n, a) { return { type: t, chart: e, native: a || null, x: void 0 !== i ? i : null, y: void 0 !== n ? n : null } } function p(t, e, i) { var h = t[a] || (t[a] = {}), u = h.resizer = function (t) { var e = document.createElement("div"), i = o + "size-monitor", n = "position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1;"; e.style.cssText = n, e.className = i, e.innerHTML = '<div class="' + i + '-expand" style="' + n + '"><div style="position:absolute;width:1000000px;height:1000000px;left:0;top:0"></div></div><div class="' + i + '-shrink" style="' + n + '"><div style="position:absolute;width:200%;height:200%;left:0; top:0"></div></div>'; var a = e.childNodes[0], r = e.childNodes[1]; e._reset = function () { a.scrollLeft = 1e6, a.scrollTop = 1e6, r.scrollLeft = 1e6, r.scrollTop = 1e6 }; var s = function () { e._reset(), t() }; return c(a, "scroll", s.bind(a, "expand")), c(r, "scroll", s.bind(r, "shrink")), e }(function (t, e) { var i = !1, a = []; return function () { a = Array.prototype.slice.call(arguments), e = e || this, i || (i = !0, n.requestAnimFrame.call(window, function () { i = !1, t.apply(e, a) })) } }(function () { if (h.resizer) return e(g("resize", i)) })); !function (t, e) { var i = t[a] || (t[a] = {}), o = i.renderProxy = function (t) { t.animationName === s && e() }; n.each(l, function (e) { c(t, e, o) }), i.reflow = !!t.offsetParent, t.classList.add(r) }(t, function () { if (h.resizer) { var e = t.parentNode; e && e !== u.parentNode && e.insertBefore(u, e.firstChild), u._reset() } }) } function v(t) { var e = t[a] || {}, i = e.resizer; delete e.resizer, function (t) { var e = t[a] || {}, i = e.renderProxy; i && (n.each(l, function (e) { f(t, e, i) }), delete e.renderProxy), t.classList.remove(r) }(t), i && i.parentNode && i.parentNode.removeChild(i) } e.exports = { _enabled: "undefined" != typeof window && "undefined" != typeof document, initialize: function () { var t = "from{opacity:0.99}to{opacity:1}"; !function (t, e) { var i = t._style || document.createElement("style"); t._style || (t._style = i, e = "/* Chart.js */\n" + e, i.setAttribute("type", "text/css"), document.getElementsByTagName("head")[0].appendChild(i)), i.appendChild(document.createTextNode(e)) }(this, "@-webkit-keyframes " + s + "{" + t + "}@keyframes " + s + "{" + t + "}." + r + "{-webkit-animation:" + s + " 0.001s;animation:" + s + " 0.001s;}") }, acquireContext: function (t, e) { "string" == typeof t ? t = document.getElementById(t) : t.length && (t = t[0]), t && t.canvas && (t = t.canvas); var i = t && t.getContext && t.getContext("2d"); return i && i.canvas === t ? (function (t, e) { var i = t.style, n = t.getAttribute("height"), o = t.getAttribute("width"); if (t[a] = { initial: { height: n, width: o, style: { display: i.display, height: i.height, width: i.width } } }, i.display = i.display || "block", null === o || "" === o) { var r = u(t, "width"); void 0 !== r && (t.width = r) } if (null === n || "" === n) if ("" === t.style.height) t.height = t.width / (e.options.aspectRatio || 2); else { var s = u(t, "height"); void 0 !== r && (t.height = s) } }(t, e), i) : null }, releaseContext: function (t) { var e = t.canvas; if (e[a]) { var i = e[a].initial;["height", "width"].forEach(function (t) { var a = i[t]; n.isNullOrUndef(a) ? e.removeAttribute(t) : e.setAttribute(t, a) }), n.each(i.style || {}, function (t, i) { e.style[i] = t }), e.width = e.width, delete e[a] } }, addEventListener: function (t, e, i) { var o = t.canvas; if ("resize" !== e) { var r = i[a] || (i[a] = {}); c(o, e, (r.proxies || (r.proxies = {}))[t.id + "_" + e] = function (e) { i(function (t, e) { var i = h[t.type] || t.type, a = n.getRelativePosition(t, e); return g(i, e, a.x, a.y, t) }(e, t)) }) } else p(o, i, t) }, removeEventListener: function (t, e, i) { var n = t.canvas; if ("resize" !== e) { var o = ((i[a] || {}).proxies || {})[t.id + "_" + e]; o && f(n, e, o) } else v(n) } }, n.addEvent = c, n.removeEvent = f }, { 45: 45 }], 48: [function (t, e, i) { "use strict"; var n = t(45), a = t(46), o = t(47), r = o._enabled ? o : a; e.exports = n.extend({ initialize: function () { }, acquireContext: function () { }, releaseContext: function () { }, addEventListener: function () { }, removeEventListener: function () { } }, r) }, { 45: 45, 46: 46, 47: 47 }], 49: [function (t, e, i) { "use strict"; var n = t(25), a = t(40), o = t(45); n._set("global", { plugins: { filler: { propagate: !0 } } }), e.exports = function () { var t = { dataset: function (t) { var e = t.fill, i = t.chart, n = i.getDatasetMeta(e), a = n && i.isDatasetVisible(e) && n.dataset._children || [], o = a.length || 0; return o ? function (t, e) { return e < o && a[e]._view || null } : null }, boundary: function (t) { var e = t.boundary, i = e ? e.x : null, n = e ? e.y : null; return function (t) { return { x: null === i ? t.x : i, y: null === n ? t.y : n } } } }; function e(t, e, i) { var n, a = t._model || {}, o = a.fill; if (void 0 === o && (o = !!a.backgroundColor), !1 === o || null === o) return !1; if (!0 === o) return "origin"; if (n = parseFloat(o, 10), isFinite(n) && Math.floor(n) === n) return "-" !== o[0] && "+" !== o[0] || (n = e + n), !(n === e || n < 0 || n >= i) && n; switch (o) { case "bottom": return "start"; case "top": return "end"; case "zero": return "origin"; case "origin": case "start": case "end": return o; default: return !1 } } function i(t) { var e, i = t.el._model || {}, n = t.el._scale || {}, a = t.fill, o = null; if (isFinite(a)) return null; if ("start" === a ? o = void 0 === i.scaleBottom ? n.bottom : i.scaleBottom : "end" === a ? o = void 0 === i.scaleTop ? n.top : i.scaleTop : void 0 !== i.scaleZero ? o = i.scaleZero : n.getBasePosition ? o = n.getBasePosition() : n.getBasePixel && (o = n.getBasePixel()), void 0 !== o && null !== o) { if (void 0 !== o.x && void 0 !== o.y) return o; if ("number" == typeof o && isFinite(o)) return { x: (e = n.isHorizontal()) ? o : null, y: e ? null : o } } return null } function r(t, e, i) { var n, a = t[e].fill, o = [e]; if (!i) return a; for (; !1 !== a && -1 === o.indexOf(a);) { if (!isFinite(a)) return a; if (!(n = t[a])) return !1; if (n.visible) return a; o.push(a), a = n.fill } return !1 } function s(e) { var i = e.fill, n = "dataset"; return !1 === i ? null : (isFinite(i) || (n = "boundary"), t[n](e)) } function l(t) { return t && !t.skip } function h(t, e, i, n, a) { var r; if (n && a) { for (t.moveTo(e[0].x, e[0].y), r = 1; r < n; ++r)o.canvas.lineTo(t, e[r - 1], e[r]); for (t.lineTo(i[a - 1].x, i[a - 1].y), r = a - 1; r > 0; --r)o.canvas.lineTo(t, i[r], i[r - 1], !0) } } return { id: "filler", afterDatasetsUpdate: function (t, n) { var o, l, h, u, d = (t.data.datasets || []).length, c = n.propagate, f = []; for (l = 0; l < d; ++l)u = null, (h = (o = t.getDatasetMeta(l)).dataset) && h._model && h instanceof a.Line && (u = { visible: t.isDatasetVisible(l), fill: e(h, l, d), chart: t, el: h }), o.$filler = u, f.push(u); for (l = 0; l < d; ++l)(u = f[l]) && (u.fill = r(f, l, c), u.boundary = i(u), u.mapper = s(u)) }, beforeDatasetDraw: function (t, e) { var i = e.meta.$filler; if (i) { var a = t.ctx, r = i.el, s = r._view, u = r._children || [], d = i.mapper, c = s.backgroundColor || n.global.defaultColor; d && c && u.length && (o.canvas.clipArea(a, t.chartArea), function (t, e, i, n, a, o) { var r, s, u, d, c, f, g, p = e.length, v = n.spanGaps, m = [], b = [], x = 0, y = 0; for (t.beginPath(), r = 0, s = p + !!o; r < s; ++r)c = i(d = e[u = r % p]._view, u, n), f = l(d), g = l(c), f && g ? (x = m.push(d), y = b.push(c)) : x && y && (v ? (f && m.push(d), g && b.push(c)) : (h(t, m, b, x, y), x = y = 0, m = [], b = [])); h(t, m, b, x, y), t.closePath(), t.fillStyle = a, t.fill() }(a, u, d, s, c, r._loop), o.canvas.unclipArea(a)) } } } } }, { 25: 25, 40: 40, 45: 45 }], 50: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45); n._set("global", { legend: { display: !0, position: "top", fullWidth: !0, reverse: !1, weight: 1e3, onClick: function (t, e) { var i = e.datasetIndex, n = this.chart, a = n.getDatasetMeta(i); a.hidden = null === a.hidden ? !n.data.datasets[i].hidden : null, n.update() }, onHover: null, labels: { boxWidth: 40, padding: 10, generateLabels: function (t) { var e = t.data; return o.isArray(e.datasets) ? e.datasets.map(function (e, i) { return { text: e.label, fillStyle: o.isArray(e.backgroundColor) ? e.backgroundColor[0] : e.backgroundColor, hidden: !t.isDatasetVisible(i), lineCap: e.borderCapStyle, lineDash: e.borderDash, lineDashOffset: e.borderDashOffset, lineJoin: e.borderJoinStyle, lineWidth: e.borderWidth, strokeStyle: e.borderColor, pointStyle: e.pointStyle, datasetIndex: i } }, this) : [] } } }, legendCallback: function (t) { var e = []; e.push('<ul class="' + t.id + '-legend">'); for (var i = 0; i < t.data.datasets.length; i++)e.push('<li><span style="background-color:' + t.data.datasets[i].backgroundColor + '"></span>'), t.data.datasets[i].label && e.push(t.data.datasets[i].label), e.push("</li>"); return e.push("</ul>"), e.join("") } }), e.exports = function (t) { var e = t.layoutService, i = o.noop; function r(t, e) { return t.usePointStyle ? e * Math.SQRT2 : t.boxWidth } t.Legend = a.extend({ initialize: function (t) { o.extend(this, t), this.legendHitBoxes = [], this.doughnutMode = !1 }, beforeUpdate: i, update: function (t, e, i) { return this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this.margins = i, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this.beforeBuildLabels(), this.buildLabels(), this.afterBuildLabels(), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate(), this.minSize }, afterUpdate: i, beforeSetDimensions: i, setDimensions: function () { this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0, this.minSize = { width: 0, height: 0 } }, afterSetDimensions: i, beforeBuildLabels: i, buildLabels: function () { var t = this, e = t.options.labels || {}, i = o.callback(e.generateLabels, [t.chart], t) || []; e.filter && (i = i.filter(function (i) { return e.filter(i, t.chart.data) })), t.options.reverse && i.reverse(), t.legendItems = i }, afterBuildLabels: i, beforeFit: i, fit: function () { var t = this, e = t.options, i = e.labels, a = e.display, s = t.ctx, l = n.global, h = o.valueOrDefault, u = h(i.fontSize, l.defaultFontSize), d = h(i.fontStyle, l.defaultFontStyle), c = h(i.fontFamily, l.defaultFontFamily), f = o.fontString(u, d, c), g = t.legendHitBoxes = [], p = t.minSize, v = t.isHorizontal(); if (v ? (p.width = t.maxWidth, p.height = a ? 10 : 0) : (p.width = a ? 10 : 0, p.height = t.maxHeight), a) if (s.font = f, v) { var m = t.lineWidths = [0], b = t.legendItems.length ? u + i.padding : 0; s.textAlign = "left", s.textBaseline = "top", o.each(t.legendItems, function (e, n) { var a = r(i, u) + u / 2 + s.measureText(e.text).width; m[m.length - 1] + a + i.padding >= t.width && (b += u + i.padding, m[m.length] = t.left), g[n] = { left: 0, top: 0, width: a, height: u }, m[m.length - 1] += a + i.padding }), p.height += b } else { var x = i.padding, y = t.columnWidths = [], k = i.padding, w = 0, M = 0, S = u + x; o.each(t.legendItems, function (t, e) { var n = r(i, u) + u / 2 + s.measureText(t.text).width; M + S > p.height && (k += w + i.padding, y.push(w), w = 0, M = 0), w = Math.max(w, n), M += S, g[e] = { left: 0, top: 0, width: n, height: u } }), k += w, y.push(w), p.width += k } t.width = p.width, t.height = p.height }, afterFit: i, isHorizontal: function () { return "top" === this.options.position || "bottom" === this.options.position }, draw: function () { var t = this, e = t.options, i = e.labels, a = n.global, s = a.elements.line, l = t.width, h = t.lineWidths; if (e.display) { var u, d = t.ctx, c = o.valueOrDefault, f = c(i.fontColor, a.defaultFontColor), g = c(i.fontSize, a.defaultFontSize), p = c(i.fontStyle, a.defaultFontStyle), v = c(i.fontFamily, a.defaultFontFamily), m = o.fontString(g, p, v); d.textAlign = "left", d.textBaseline = "middle", d.lineWidth = .5, d.strokeStyle = f, d.fillStyle = f, d.font = m; var b = r(i, g), x = t.legendHitBoxes, y = t.isHorizontal(); u = y ? { x: t.left + (l - h[0]) / 2, y: t.top + i.padding, line: 0 } : { x: t.left + i.padding, y: t.top + i.padding, line: 0 }; var k = g + i.padding; o.each(t.legendItems, function (n, r) { var f = d.measureText(n.text).width, p = b + g / 2 + f, v = u.x, m = u.y; y ? v + p >= l && (m = u.y += k, u.line++ , v = u.x = t.left + (l - h[u.line]) / 2) : m + k > t.bottom && (v = u.x = v + t.columnWidths[u.line] + i.padding, m = u.y = t.top + i.padding, u.line++), function (t, i, n) { if (!(isNaN(b) || b <= 0)) { d.save(), d.fillStyle = c(n.fillStyle, a.defaultColor), d.lineCap = c(n.lineCap, s.borderCapStyle), d.lineDashOffset = c(n.lineDashOffset, s.borderDashOffset), d.lineJoin = c(n.lineJoin, s.borderJoinStyle), d.lineWidth = c(n.lineWidth, s.borderWidth), d.strokeStyle = c(n.strokeStyle, a.defaultColor); var r = 0 === c(n.lineWidth, s.borderWidth); if (d.setLineDash && d.setLineDash(c(n.lineDash, s.borderDash)), e.labels && e.labels.usePointStyle) { var l = g * Math.SQRT2 / 2, h = l / Math.SQRT2, u = t + h, f = i + h; o.canvas.drawPoint(d, n.pointStyle, l, u, f) } else r || d.strokeRect(t, i, b, g), d.fillRect(t, i, b, g); d.restore() } }(v, m, n), x[r].left = v, x[r].top = m, function (t, e, i, n) { var a = g / 2, o = b + a + t, r = e + a; d.fillText(i.text, o, r), i.hidden && (d.beginPath(), d.lineWidth = 2, d.moveTo(o, r), d.lineTo(o + n, r), d.stroke()) }(v, m, n, f), y ? u.x += p + i.padding : u.y += k }) } }, handleEvent: function (t) { var e = this.options, i = "mouseup" === t.type ? "click" : t.type, n = !1; if ("mousemove" === i) { if (!e.onHover) return } else { if ("click" !== i) return; if (!e.onClick) return } var a = t.x, o = t.y; if (a >= this.left && a <= this.right && o >= this.top && o <= this.bottom) for (var r = this.legendHitBoxes, s = 0; s < r.length; ++s) { var l = r[s]; if (a >= l.left && a <= l.left + l.width && o >= l.top && o <= l.top + l.height) { if ("click" === i) { e.onClick.call(this, t.native, this.legendItems[s]), n = !0; break } if ("mousemove" === i) { e.onHover.call(this, t.native, this.legendItems[s]), n = !0; break } } } return n } }); function s(i, n) { var a = new t.Legend({ ctx: i.ctx, options: n, chart: i }); e.configure(i, a, n), e.addBox(i, a), i.legend = a } return { id: "legend", beforeInit: function (t) { var e = t.options.legend; e && s(t, e) }, beforeUpdate: function (t) { var i = t.options.legend, a = t.legend; i ? (o.mergeIf(i, n.global.legend), a ? (e.configure(t, a, i), a.options = i) : s(t, i)) : a && (e.removeBox(t, a), delete t.legend) }, afterEvent: function (t, e) { var i = t.legend; i && i.handleEvent(e) } } } }, { 25: 25, 26: 26, 45: 45 }], 51: [function (t, e, i) { "use strict"; var n = t(25), a = t(26), o = t(45); n._set("global", { title: { display: !1, fontStyle: "bold", fullWidth: !0, lineHeight: 1.2, padding: 10, position: "top", text: "", weight: 2e3 } }), e.exports = function (t) { var e = t.layoutService, i = o.noop; t.Title = a.extend({ initialize: function (t) { o.extend(this, t), this.legendHitBoxes = [] }, beforeUpdate: i, update: function (t, e, i) { return this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this.margins = i, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this.beforeBuildLabels(), this.buildLabels(), this.afterBuildLabels(), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate(), this.minSize }, afterUpdate: i, beforeSetDimensions: i, setDimensions: function () { this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0, this.minSize = { width: 0, height: 0 } }, afterSetDimensions: i, beforeBuildLabels: i, buildLabels: i, afterBuildLabels: i, beforeFit: i, fit: function () { var t = o.valueOrDefault, e = this.options, i = e.display, a = t(e.fontSize, n.global.defaultFontSize), r = this.minSize, s = o.isArray(e.text) ? e.text.length : 1, l = o.options.toLineHeight(e.lineHeight, a), h = i ? s * l + 2 * e.padding : 0; this.isHorizontal() ? (r.width = this.maxWidth, r.height = h) : (r.width = h, r.height = this.maxHeight), this.width = r.width, this.height = r.height }, afterFit: i, isHorizontal: function () { var t = this.options.position; return "top" === t || "bottom" === t }, draw: function () { var t = this.ctx, e = o.valueOrDefault, i = this.options, a = n.global; if (i.display) { var r, s, l, h = e(i.fontSize, a.defaultFontSize), u = e(i.fontStyle, a.defaultFontStyle), d = e(i.fontFamily, a.defaultFontFamily), c = o.fontString(h, u, d), f = o.options.toLineHeight(i.lineHeight, h), g = f / 2 + i.padding, p = 0, v = this.top, m = this.left, b = this.bottom, x = this.right; t.fillStyle = e(i.fontColor, a.defaultFontColor), t.font = c, this.isHorizontal() ? (s = m + (x - m) / 2, l = v + g, r = x - m) : (s = "left" === i.position ? m + g : x - g, l = v + (b - v) / 2, r = b - v, p = Math.PI * ("left" === i.position ? -.5 : .5)), t.save(), t.translate(s, l), t.rotate(p), t.textAlign = "center", t.textBaseline = "middle"; var y = i.text; if (o.isArray(y)) for (var k = 0, w = 0; w < y.length; ++w)t.fillText(y[w], 0, k, r), k += f; else t.fillText(y, 0, 0, r); t.restore() } } }); function r(i, n) { var a = new t.Title({ ctx: i.ctx, options: n, chart: i }); e.configure(i, a, n), e.addBox(i, a), i.titleBlock = a } return { id: "title", beforeInit: function (t) { var e = t.options.title; e && r(t, e) }, beforeUpdate: function (i) { var a = i.options.title, s = i.titleBlock; a ? (o.mergeIf(a, n.global.title), s ? (e.configure(i, s, a), s.options = a) : r(i, a)) : s && (t.layoutService.removeBox(i, s), delete i.titleBlock) } } } }, { 25: 25, 26: 26, 45: 45 }], 52: [function (t, e, i) { "use strict"; e.exports = function (t) { var e = t.Scale.extend({ getLabels: function () { var t = this.chart.data; return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels }, determineDataLimits: function () { var t = this.getLabels(); this.minIndex = 0, this.maxIndex = t.length - 1; var e; void 0 !== this.options.ticks.min && (e = t.indexOf(this.options.ticks.min), this.minIndex = -1 !== e ? e : this.minIndex), void 0 !== this.options.ticks.max && (e = t.indexOf(this.options.ticks.max), this.maxIndex = -1 !== e ? e : this.maxIndex), this.min = t[this.minIndex], this.max = t[this.maxIndex] }, buildTicks: function () { var t = this.getLabels(); this.ticks = 0 === this.minIndex && this.maxIndex === t.length - 1 ? t : t.slice(this.minIndex, this.maxIndex + 1) }, getLabelForIndex: function (t, e) { var i = this.chart.data, n = this.isHorizontal(); return i.yLabels && !n ? this.getRightValue(i.datasets[e].data[t]) : this.ticks[t - this.minIndex] }, getPixelForValue: function (t, e) { var i, n = this.options.offset, a = Math.max(this.maxIndex + 1 - this.minIndex - (n ? 0 : 1), 1); if (void 0 !== t && null !== t && (i = this.isHorizontal() ? t.x : t.y), void 0 !== i || void 0 !== t && isNaN(e)) { var o = this.getLabels(); t = i || t; var r = o.indexOf(t); e = -1 !== r ? r : e } if (this.isHorizontal()) { var s = this.width / a, l = s * (e - this.minIndex); return n && (l += s / 2), this.left + Math.round(l) } var h = this.height / a, u = h * (e - this.minIndex); return n && (u += h / 2), this.top + Math.round(u) }, getPixelForTick: function (t) { return this.getPixelForValue(this.ticks[t], t + this.minIndex, null) }, getValueForPixel: function (t) { var e = this.options.offset, i = Math.max(this._ticks.length - (e ? 0 : 1), 1), n = this.isHorizontal(), a = (n ? this.width : this.height) / i; return t -= n ? this.left : this.top, e && (t -= a / 2), (t <= 0 ? 0 : Math.round(t / a)) + this.minIndex }, getBasePixel: function () { return this.bottom } }); t.scaleService.registerScaleType("category", e, { position: "bottom" }) } }, {}], 53: [function (t, e, i) { "use strict"; var n = t(25), a = t(45), o = t(34); e.exports = function (t) { var e = { position: "left", ticks: { callback: o.formatters.linear } }, i = t.LinearScaleBase.extend({ determineDataLimits: function () { var t = this, e = t.options, i = t.chart, n = i.data.datasets, o = t.isHorizontal(); function r(e) { return o ? e.xAxisID === t.id : e.yAxisID === t.id } t.min = null, t.max = null; var s = e.stacked; if (void 0 === s && a.each(n, function (t, e) { if (!s) { var n = i.getDatasetMeta(e); i.isDatasetVisible(e) && r(n) && void 0 !== n.stack && (s = !0) } }), e.stacked || s) { var l = {}; a.each(n, function (n, o) { var s = i.getDatasetMeta(o), h = [s.type, void 0 === e.stacked && void 0 === s.stack ? o : "", s.stack].join("."); void 0 === l[h] && (l[h] = { positiveValues: [], negativeValues: [] }); var u = l[h].positiveValues, d = l[h].negativeValues; i.isDatasetVisible(o) && r(s) && a.each(n.data, function (i, n) { var a = +t.getRightValue(i); isNaN(a) || s.data[n].hidden || (u[n] = u[n] || 0, d[n] = d[n] || 0, e.relativePoints ? u[n] = 100 : a < 0 ? d[n] += a : u[n] += a) }) }), a.each(l, function (e) { var i = e.positiveValues.concat(e.negativeValues), n = a.min(i), o = a.max(i); t.min = null === t.min ? n : Math.min(t.min, n), t.max = null === t.max ? o : Math.max(t.max, o) }) } else a.each(n, function (e, n) { var o = i.getDatasetMeta(n); i.isDatasetVisible(n) && r(o) && a.each(e.data, function (e, i) { var n = +t.getRightValue(e); isNaN(n) || o.data[i].hidden || (null === t.min ? t.min = n : n < t.min && (t.min = n), null === t.max ? t.max = n : n > t.max && (t.max = n)) }) }); t.min = isFinite(t.min) && !isNaN(t.min) ? t.min : 0, t.max = isFinite(t.max) && !isNaN(t.max) ? t.max : 1, this.handleTickRangeOptions() }, getTickLimit: function () { var t, e = this.options.ticks; if (this.isHorizontal()) t = Math.min(e.maxTicksLimit ? e.maxTicksLimit : 11, Math.ceil(this.width / 50)); else { var i = a.valueOrDefault(e.fontSize, n.global.defaultFontSize); t = Math.min(e.maxTicksLimit ? e.maxTicksLimit : 11, Math.ceil(this.height / (2 * i))) } return t }, handleDirectionalChanges: function () { this.isHorizontal() || this.ticks.reverse() }, getLabelForIndex: function (t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]) }, getPixelForValue: function (t) { var e = this.start, i = +this.getRightValue(t), n = this.end - e; return this.isHorizontal() ? this.left + this.width / n * (i - e) : this.bottom - this.height / n * (i - e) }, getValueForPixel: function (t) { var e = this.isHorizontal(), i = e ? this.width : this.height, n = (e ? t - this.left : this.bottom - t) / i; return this.start + (this.end - this.start) * n }, getPixelForTick: function (t) { return this.getPixelForValue(this.ticksAsNumbers[t]) } }); t.scaleService.registerScaleType("linear", i, e) } }, { 25: 25, 34: 34, 45: 45 }], 54: [function (t, e, i) { "use strict"; var n = t(45), a = t(34); e.exports = function (t) { var e = n.noop; t.LinearScaleBase = t.Scale.extend({ getRightValue: function (e) { return "string" == typeof e ? +e : t.Scale.prototype.getRightValue.call(this, e) }, handleTickRangeOptions: function () { var t = this.options.ticks; if (t.beginAtZero) { var e = n.sign(this.min), i = n.sign(this.max); e < 0 && i < 0 ? this.max = 0 : e > 0 && i > 0 && (this.min = 0) } var a = void 0 !== t.min || void 0 !== t.suggestedMin, o = void 0 !== t.max || void 0 !== t.suggestedMax; void 0 !== t.min ? this.min = t.min : void 0 !== t.suggestedMin && (null === this.min ? this.min = t.suggestedMin : this.min = Math.min(this.min, t.suggestedMin)), void 0 !== t.max ? this.max = t.max : void 0 !== t.suggestedMax && (null === this.max ? this.max = t.suggestedMax : this.max = Math.max(this.max, t.suggestedMax)), a !== o && this.min >= this.max && (a ? this.max = this.min + 1 : this.min = this.max - 1), this.min === this.max && (this.max++ , t.beginAtZero || this.min--) }, getTickLimit: e, handleDirectionalChanges: e, buildTicks: function () { var t = this.options.ticks, e = this.getTickLimit(), i = { maxTicks: e = Math.max(2, e), min: t.min, max: t.max, stepSize: n.valueOrDefault(t.fixedStepSize, t.stepSize) }, o = this.ticks = a.generators.linear(i, this); this.handleDirectionalChanges(), this.max = n.max(o), this.min = n.min(o), t.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max) }, convertTicksToLabels: function () { this.ticksAsNumbers = this.ticks.slice(), this.zeroLineIndex = this.ticks.indexOf(0), t.Scale.prototype.convertTicksToLabels.call(this) } }) } }, { 34: 34, 45: 45 }], 55: [function (t, e, i) { "use strict"; var n = t(45), a = t(34); e.exports = function (t) { var e = { position: "left", ticks: { callback: a.formatters.logarithmic } }, i = t.Scale.extend({ determineDataLimits: function () { var t = this, e = t.options, i = t.chart, a = i.data.datasets, o = t.isHorizontal(); function r(e) { return o ? e.xAxisID === t.id : e.yAxisID === t.id } t.min = null, t.max = null, t.minNotZero = null; var s = e.stacked; if (void 0 === s && n.each(a, function (t, e) { if (!s) { var n = i.getDatasetMeta(e); i.isDatasetVisible(e) && r(n) && void 0 !== n.stack && (s = !0) } }), e.stacked || s) { var l = {}; n.each(a, function (a, o) { var s = i.getDatasetMeta(o), h = [s.type, void 0 === e.stacked && void 0 === s.stack ? o : "", s.stack].join("."); i.isDatasetVisible(o) && r(s) && (void 0 === l[h] && (l[h] = []), n.each(a.data, function (e, i) { var n = l[h], a = +t.getRightValue(e); isNaN(a) || s.data[i].hidden || a < 0 || (n[i] = n[i] || 0, n[i] += a) })) }), n.each(l, function (e) { if (e.length > 0) { var i = n.min(e), a = n.max(e); t.min = null === t.min ? i : Math.min(t.min, i), t.max = null === t.max ? a : Math.max(t.max, a) } }) } else n.each(a, function (e, a) { var o = i.getDatasetMeta(a); i.isDatasetVisible(a) && r(o) && n.each(e.data, function (e, i) { var n = +t.getRightValue(e); isNaN(n) || o.data[i].hidden || n < 0 || (null === t.min ? t.min = n : n < t.min && (t.min = n), null === t.max ? t.max = n : n > t.max && (t.max = n), 0 !== n && (null === t.minNotZero || n < t.minNotZero) && (t.minNotZero = n)) }) }); this.handleTickRangeOptions() }, handleTickRangeOptions: function () { var t = this.options.ticks, e = n.valueOrDefault; this.min = e(t.min, this.min), this.max = e(t.max, this.max), this.min === this.max && (0 !== this.min && null !== this.min ? (this.min = Math.pow(10, Math.floor(n.log10(this.min)) - 1), this.max = Math.pow(10, Math.floor(n.log10(this.max)) + 1)) : (this.min = 1, this.max = 10)), null === this.min && (this.min = Math.pow(10, Math.floor(n.log10(this.max)) - 1)), null === this.max && (this.max = 0 !== this.min ? Math.pow(10, Math.floor(n.log10(this.min)) + 1) : 10), null === this.minNotZero && (this.min > 0 ? this.minNotZero = this.min : this.max < 1 ? this.minNotZero = Math.pow(10, Math.floor(n.log10(this.max))) : this.minNotZero = 1) }, buildTicks: function () { var t = this.options.ticks, e = !this.isHorizontal(), i = { min: t.min, max: t.max }, o = this.ticks = a.generators.logarithmic(i, this); this.max = n.max(o), this.min = n.min(o), t.reverse ? (e = !e, this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), e && o.reverse() }, convertTicksToLabels: function () { this.tickValues = this.ticks.slice(), t.Scale.prototype.convertTicksToLabels.call(this) }, getLabelForIndex: function (t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]) }, getPixelForTick: function (t) { return this.getPixelForValue(this.tickValues[t]) }, _getFirstTickValue: function (t) { var e = Math.floor(n.log10(t)); return Math.floor(t / Math.pow(10, e)) * Math.pow(10, e) }, getPixelForValue: function (e) { var i, a, o, r, s, l = this.options.ticks.reverse, h = n.log10, u = this._getFirstTickValue(this.minNotZero), d = 0; return e = +this.getRightValue(e), l ? (o = this.end, r = this.start, s = -1) : (o = this.start, r = this.end, s = 1), this.isHorizontal() ? (i = this.width, a = l ? this.right : this.left) : (i = this.height, s *= -1, a = l ? this.top : this.bottom), e !== o && (0 === o && (i -= d = n.getValueOrDefault(this.options.ticks.fontSize, t.defaults.global.defaultFontSize), o = u), 0 !== e && (d += i / (h(r) - h(o)) * (h(e) - h(o))), a += s * d), a }, getValueForPixel: function (e) { var i, a, o, r, s = this.options.ticks.reverse, l = n.log10, h = this._getFirstTickValue(this.minNotZero); if (s ? (a = this.end, o = this.start) : (a = this.start, o = this.end), this.isHorizontal() ? (i = this.width, r = s ? this.right - e : e - this.left) : (i = this.height, r = s ? e - this.top : this.bottom - e), r !== a) { if (0 === a) { var u = n.getValueOrDefault(this.options.ticks.fontSize, t.defaults.global.defaultFontSize); r -= u, i -= u, a = h } r *= l(o) - l(a), r /= i, r = Math.pow(10, l(a) + r) } return r } }); t.scaleService.registerScaleType("logarithmic", i, e) } }, { 34: 34, 45: 45 }], 56: [function (t, e, i) { "use strict"; var n = t(25), a = t(45), o = t(34); e.exports = function (t) { var e = n.global, i = { display: !0, animate: !0, position: "chartArea", angleLines: { display: !0, color: "rgba(0, 0, 0, 0.1)", lineWidth: 1 }, gridLines: { circular: !1 }, ticks: { showLabelBackdrop: !0, backdropColor: "rgba(255,255,255,0.75)", backdropPaddingY: 2, backdropPaddingX: 2, callback: o.formatters.linear }, pointLabels: { display: !0, fontSize: 10, callback: function (t) { return t } } }; function r(t) { var e = t.options; return e.angleLines.display || e.pointLabels.display ? t.chart.data.labels.length : 0 } function s(t) { var i = t.options.pointLabels, n = a.valueOrDefault(i.fontSize, e.defaultFontSize), o = a.valueOrDefault(i.fontStyle, e.defaultFontStyle), r = a.valueOrDefault(i.fontFamily, e.defaultFontFamily); return { size: n, style: o, family: r, font: a.fontString(n, o, r) } } function l(t, e, i, n, a) { return t === n || t === a ? { start: e - i / 2, end: e + i / 2 } : t < n || t > a ? { start: e - i - 5, end: e } : { start: e, end: e + i + 5 } } function h(t, e, i, n) { if (a.isArray(e)) for (var o = i.y, r = 1.5 * n, s = 0; s < e.length; ++s)t.fillText(e[s], i.x, o), o += r; else t.fillText(e, i.x, i.y) } function u(t) { return a.isNumber(t) ? t : 0 } var d = t.LinearScaleBase.extend({ setDimensions: function () { var t = this.options, i = t.ticks; this.width = this.maxWidth, this.height = this.maxHeight, this.xCenter = Math.round(this.width / 2), this.yCenter = Math.round(this.height / 2); var n = a.min([this.height, this.width]), o = a.valueOrDefault(i.fontSize, e.defaultFontSize); this.drawingArea = t.display ? n / 2 - (o / 2 + i.backdropPaddingY) : n / 2 }, determineDataLimits: function () { var t = this, e = t.chart, i = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY; a.each(e.data.datasets, function (o, r) { if (e.isDatasetVisible(r)) { var s = e.getDatasetMeta(r); a.each(o.data, function (e, a) { var o = +t.getRightValue(e); isNaN(o) || s.data[a].hidden || (i = Math.min(o, i), n = Math.max(o, n)) }) } }), t.min = i === Number.POSITIVE_INFINITY ? 0 : i, t.max = n === Number.NEGATIVE_INFINITY ? 0 : n, t.handleTickRangeOptions() }, getTickLimit: function () { var t = this.options.ticks, i = a.valueOrDefault(t.fontSize, e.defaultFontSize); return Math.min(t.maxTicksLimit ? t.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * i))) }, convertTicksToLabels: function () { t.LinearScaleBase.prototype.convertTicksToLabels.call(this), this.pointLabels = this.chart.data.labels.map(this.options.pointLabels.callback, this) }, getLabelForIndex: function (t, e) { return +this.getRightValue(this.chart.data.datasets[e].data[t]) }, fit: function () { this.options.pointLabels.display ? function (t) { var e, i, n, o = s(t), h = Math.min(t.height / 2, t.width / 2), u = { r: t.width, l: 0, t: t.height, b: 0 }, d = {}; t.ctx.font = o.font, t._pointLabelSizes = []; var c = r(t); for (e = 0; e < c; e++) { n = t.getPointPosition(e, h), m = t.ctx, b = o.size, x = t.pointLabels[e] || "", i = a.isArray(x) ? { w: a.longestText(m, m.font, x), h: x.length * b + 1.5 * (x.length - 1) * b } : { w: m.measureText(x).width, h: b }, t._pointLabelSizes[e] = i; var f = t.getIndexAngle(e), g = a.toDegrees(f) % 360, p = l(g, n.x, i.w, 0, 180), v = l(g, n.y, i.h, 90, 270); p.start < u.l && (u.l = p.start, d.l = f), p.end > u.r && (u.r = p.end, d.r = f), v.start < u.t && (u.t = v.start, d.t = f), v.end > u.b && (u.b = v.end, d.b = f) } var m, b, x; t.setReductions(h, u, d) }(this) : function (t) { var e = Math.min(t.height / 2, t.width / 2); t.drawingArea = Math.round(e), t.setCenterPoint(0, 0, 0, 0) }(this) }, setReductions: function (t, e, i) { var n = e.l / Math.sin(i.l), a = Math.max(e.r - this.width, 0) / Math.sin(i.r), o = -e.t / Math.cos(i.t), r = -Math.max(e.b - this.height, 0) / Math.cos(i.b); n = u(n), a = u(a), o = u(o), r = u(r), this.drawingArea = Math.min(Math.round(t - (n + a) / 2), Math.round(t - (o + r) / 2)), this.setCenterPoint(n, a, o, r) }, setCenterPoint: function (t, e, i, n) { var a = this.width - e - this.drawingArea, o = t + this.drawingArea, r = i + this.drawingArea, s = this.height - n - this.drawingArea; this.xCenter = Math.round((o + a) / 2 + this.left), this.yCenter = Math.round((r + s) / 2 + this.top) }, getIndexAngle: function (t) { return t * (2 * Math.PI / r(this)) + (this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0) * Math.PI * 2 / 360 }, getDistanceFromCenterForValue: function (t) { if (null === t) return 0; var e = this.drawingArea / (this.max - this.min); return this.options.ticks.reverse ? (this.max - t) * e : (t - this.min) * e }, getPointPosition: function (t, e) { var i = this.getIndexAngle(t) - Math.PI / 2; return { x: Math.round(Math.cos(i) * e) + this.xCenter, y: Math.round(Math.sin(i) * e) + this.yCenter } }, getPointPositionForValue: function (t, e) { return this.getPointPosition(t, this.getDistanceFromCenterForValue(e)) }, getBasePosition: function () { var t = this.min, e = this.max; return this.getPointPositionForValue(0, this.beginAtZero ? 0 : t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0) }, draw: function () { var t = this, i = t.options, n = i.gridLines, o = i.ticks, l = a.valueOrDefault; if (i.display) { var u = t.ctx, d = this.getIndexAngle(0), c = l(o.fontSize, e.defaultFontSize), f = l(o.fontStyle, e.defaultFontStyle), g = l(o.fontFamily, e.defaultFontFamily), p = a.fontString(c, f, g); a.each(t.ticks, function (i, s) { if (s > 0 || o.reverse) { var h = t.getDistanceFromCenterForValue(t.ticksAsNumbers[s]); if (n.display && 0 !== s && function (t, e, i, n) { var o = t.ctx; if (o.strokeStyle = a.valueAtIndexOrDefault(e.color, n - 1), o.lineWidth = a.valueAtIndexOrDefault(e.lineWidth, n - 1), t.options.gridLines.circular) o.beginPath(), o.arc(t.xCenter, t.yCenter, i, 0, 2 * Math.PI), o.closePath(), o.stroke(); else { var s = r(t); if (0 === s) return; o.beginPath(); var l = t.getPointPosition(0, i); o.moveTo(l.x, l.y); for (var h = 1; h < s; h++)l = t.getPointPosition(h, i), o.lineTo(l.x, l.y); o.closePath(), o.stroke() } }(t, n, h, s), o.display) { var f = l(o.fontColor, e.defaultFontColor); if (u.font = p, u.save(), u.translate(t.xCenter, t.yCenter), u.rotate(d), o.showLabelBackdrop) { var g = u.measureText(i).width; u.fillStyle = o.backdropColor, u.fillRect(-g / 2 - o.backdropPaddingX, -h - c / 2 - o.backdropPaddingY, g + 2 * o.backdropPaddingX, c + 2 * o.backdropPaddingY) } u.textAlign = "center", u.textBaseline = "middle", u.fillStyle = f, u.fillText(i, 0, -h), u.restore() } } }), (i.angleLines.display || i.pointLabels.display) && function (t) { var i = t.ctx, n = a.valueOrDefault, o = t.options, l = o.angleLines, u = o.pointLabels; i.lineWidth = l.lineWidth, i.strokeStyle = l.color; var d = t.getDistanceFromCenterForValue(o.ticks.reverse ? t.min : t.max), c = s(t); i.textBaseline = "top"; for (var f = r(t) - 1; f >= 0; f--) { if (l.display) { var g = t.getPointPosition(f, d); i.beginPath(), i.moveTo(t.xCenter, t.yCenter), i.lineTo(g.x, g.y), i.stroke(), i.closePath() } if (u.display) { var p = t.getPointPosition(f, d + 5), v = n(u.fontColor, e.defaultFontColor); i.font = c.font, i.fillStyle = v; var m = t.getIndexAngle(f), b = a.toDegrees(m); i.textAlign = (w = b, 0 === w || 180 === w ? "center" : w < 180 ? "left" : "right"), x = b, y = t._pointLabelSizes[f], k = p, 90 === x || 270 === x ? k.y -= y.h / 2 : (x > 270 || x < 90) && (k.y -= y.h), h(i, t.pointLabels[f] || "", p, c.size) } } var x, y, k, w }(t) } } }); t.scaleService.registerScaleType("radialLinear", d, i) } }, { 25: 25, 34: 34, 45: 45 }], 57: [function (t, e, i) { "use strict"; var n = t(1); n = "function" == typeof n ? n : window.moment; var a = t(25), o = t(45), r = Number.MIN_SAFE_INTEGER || -9007199254740991, s = Number.MAX_SAFE_INTEGER || 9007199254740991, l = { millisecond: { common: !0, size: 1, steps: [1, 2, 5, 10, 20, 50, 100, 250, 500] }, second: { common: !0, size: 1e3, steps: [1, 2, 5, 10, 30] }, minute: { common: !0, size: 6e4, steps: [1, 2, 5, 10, 30] }, hour: { common: !0, size: 36e5, steps: [1, 2, 3, 6, 12] }, day: { common: !0, size: 864e5, steps: [1, 2, 5] }, week: { common: !1, size: 6048e5, steps: [1, 2, 3, 4] }, month: { common: !0, size: 2628e6, steps: [1, 2, 3] }, quarter: { common: !1, size: 7884e6, steps: [1, 2, 3, 4] }, year: { common: !0, size: 3154e7 } }, h = Object.keys(l); function u(t, e) { return t - e } function d(t) { var e, i, n, a = {}, o = []; for (e = 0, i = t.length; e < i; ++e)a[n = t[e]] || (a[n] = !0, o.push(n)); return o } function c(t, e, i, n) { var a = function (t, e, i) { for (var n, a, o, r = 0, s = t.length - 1; r >= 0 && r <= s;) { if (a = t[(n = r + s >> 1) - 1] || null, o = t[n], !a) return { lo: null, hi: o }; if (o[e] < i) r = n + 1; else { if (!(a[e] > i)) return { lo: a, hi: o }; s = n - 1 } } return { lo: o, hi: null } }(t, e, i), o = a.lo ? a.hi ? a.lo : t[t.length - 2] : t[0], r = a.lo ? a.hi ? a.hi : t[t.length - 1] : t[1], s = r[e] - o[e], l = s ? (i - o[e]) / s : 0, h = (r[n] - o[n]) * l; return o[n] + h } function f(t, e) { var i = e.parser, a = e.parser || e.format; return "function" == typeof i ? i(t) : "string" == typeof t && "string" == typeof a ? n(t, a) : (t instanceof n || (t = n(t)), t.isValid() ? t : "function" == typeof a ? a(t) : t) } function g(t, e) { if (o.isNullOrUndef(t)) return null; var i = e.options.time, n = f(e.getRightValue(t), i); return n.isValid() ? (i.round && n.startOf(i.round), n.valueOf()) : null } function p(t) { for (var e = h.indexOf(t) + 1, i = h.length; e < i; ++e)if (l[h[e]].common) return h[e] } function v(t, e, i, a) { var r, u = a.time, d = u.unit || function (t, e, i, n) { var a, o, r, u = h.length; for (a = h.indexOf(t); a < u - 1; ++a)if (r = (o = l[h[a]]).steps ? o.steps[o.steps.length - 1] : s, o.common && Math.ceil((i - e) / (r * o.size)) <= n) return h[a]; return h[u - 1] }(u.minUnit, t, e, i), c = p(d), f = o.valueOrDefault(u.stepSize, u.unitStepSize), g = "week" === d && u.isoWeekday, v = a.ticks.major.enabled, m = l[d], b = n(t), x = n(e), y = []; for (f || (f = function (t, e, i, n) { var a, o, r, s = e - t, h = l[i], u = h.size, d = h.steps; if (!d) return Math.ceil(s / (n * u)); for (a = 0, o = d.length; a < o && (r = d[a], !(Math.ceil(s / (u * r)) <= n)); ++a); return r }(t, e, d, i)), g && (b = b.isoWeekday(g), x = x.isoWeekday(g)), b = b.startOf(g ? "day" : d), (x = x.startOf(g ? "day" : d)) < e && x.add(1, d), r = n(b), v && c && !g && !u.round && (r.startOf(c), r.add(~~((b - r) / (m.size * f)) * f, d)); r < x; r.add(f, d))y.push(+r); return y.push(+r), y } e.exports = function (t) { var e = t.Scale.extend({ initialize: function () { if (!n) throw new Error("Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com"); this.mergeTicksOptions(), t.Scale.prototype.initialize.call(this) }, update: function () { var e = this.options; return e.time && e.time.format && console.warn("options.time.format is deprecated and replaced by options.time.parser."), t.Scale.prototype.update.apply(this, arguments) }, getRightValue: function (e) { return e && void 0 !== e.t && (e = e.t), t.Scale.prototype.getRightValue.call(this, e) }, determineDataLimits: function () { var t, e, i, a, l, h, c = this.chart, f = this.options.time, p = f.unit || "day", v = s, m = r, b = [], x = [], y = []; for (t = 0, i = c.data.labels.length; t < i; ++t)y.push(g(c.data.labels[t], this)); for (t = 0, i = (c.data.datasets || []).length; t < i; ++t)if (c.isDatasetVisible(t)) if (l = c.data.datasets[t].data, o.isObject(l[0])) for (x[t] = [], e = 0, a = l.length; e < a; ++e)h = g(l[e], this), b.push(h), x[t][e] = h; else b.push.apply(b, y), x[t] = y.slice(0); else x[t] = []; y.length && (y = d(y).sort(u), v = Math.min(v, y[0]), m = Math.max(m, y[y.length - 1])), b.length && (b = d(b).sort(u), v = Math.min(v, b[0]), m = Math.max(m, b[b.length - 1])), v = g(f.min, this) || v, m = g(f.max, this) || m, v = v === s ? +n().startOf(p) : v, m = m === r ? +n().endOf(p) + 1 : m, this.min = Math.min(v, m), this.max = Math.max(v + 1, m), this._horizontal = this.isHorizontal(), this._table = [], this._timestamps = { data: b, datasets: x, labels: y } }, buildTicks: function () { var t, e, i, a = this.min, o = this.max, r = this.options, s = r.time, u = [], d = []; switch (r.ticks.source) { case "data": u = this._timestamps.data; break; case "labels": u = this._timestamps.labels; break; case "auto": default: u = v(a, o, this.getLabelCapacity(a), r) }for ("ticks" === r.bounds && u.length && (a = u[0], o = u[u.length - 1]), a = g(s.min, this) || a, o = g(s.max, this) || o, t = 0, e = u.length; t < e; ++t)(i = u[t]) >= a && i <= o && d.push(i); return this.min = a, this.max = o, this._unit = s.unit || function (t, e, i, a) { var o, r, s = n.duration(n(a).diff(n(i))); for (o = h.length - 1; o >= h.indexOf(e); o--)if (r = h[o], l[r].common && s.as(r) >= t.length) return r; return h[e ? h.indexOf(e) : 0] }(d, s.minUnit, this.min, this.max), this._majorUnit = p(this._unit), this._table = function (t, e, i, n) { if ("linear" === n || !t.length) return [{ time: e, pos: 0 }, { time: i, pos: 1 }]; var a, o, r, s, l, h = [], u = [e]; for (a = 0, o = t.length; a < o; ++a)(s = t[a]) > e && s < i && u.push(s); for (u.push(i), a = 0, o = u.length; a < o; ++a)l = u[a + 1], r = u[a - 1], s = u[a], void 0 !== r && void 0 !== l && Math.round((l + r) / 2) === s || h.push({ time: s, pos: a / (o - 1) }); return h }(this._timestamps.data, a, o, r.distribution), this._offsets = function (t, e, i, n, a) { var o, r, s = 0, l = 0; return a.offset && e.length && (a.time.min || (o = e.length > 1 ? e[1] : n, r = e[0], s = (c(t, "time", o, "pos") - c(t, "time", r, "pos")) / 2), a.time.max || (o = e[e.length - 1], r = e.length > 1 ? e[e.length - 2] : i, l = (c(t, "time", o, "pos") - c(t, "time", r, "pos")) / 2)), { left: s, right: l } }(this._table, d, a, o, r), function (t, e) { var i, a, o, r, s = []; for (i = 0, a = t.length; i < a; ++i)o = t[i], r = !!e && o === +n(o).startOf(e), s.push({ value: o, major: r }); return s }(d, this._majorUnit) }, getLabelForIndex: function (t, e) { var i = this.chart.data, n = this.options.time, a = i.labels && t < i.labels.length ? i.labels[t] : "", r = i.datasets[e].data[t]; return o.isObject(r) && (a = this.getRightValue(r)), n.tooltipFormat && (a = f(a, n).format(n.tooltipFormat)), a }, tickFormatFunction: function (t, e, i, n) { var a = this.options, r = t.valueOf(), s = a.time.displayFormats, l = s[this._unit], h = this._majorUnit, u = s[h], d = t.clone().startOf(h).valueOf(), c = a.ticks.major, f = c.enabled && h && u && r === d, g = t.format(n || (f ? u : l)), p = f ? c : a.ticks.minor, v = o.valueOrDefault(p.callback, p.userCallback); return v ? v(g, e, i) : g }, convertTicksToLabels: function (t) { var e, i, a = []; for (e = 0, i = t.length; e < i; ++e)a.push(this.tickFormatFunction(n(t[e].value), e, t)); return a }, getPixelForOffset: function (t) { var e = this._horizontal ? this.width : this.height, i = this._horizontal ? this.left : this.top, n = c(this._table, "time", t, "pos"); return i + e * (this._offsets.left + n) / (this._offsets.left + 1 + this._offsets.right) }, getPixelForValue: function (t, e, i) { var n = null; if (void 0 !== e && void 0 !== i && (n = this._timestamps.datasets[i][e]), null === n && (n = g(t, this)), null !== n) return this.getPixelForOffset(n) }, getPixelForTick: function (t) { var e = this.getTicks(); return t >= 0 && t < e.length ? this.getPixelForOffset(e[t].value) : null }, getValueForPixel: function (t) { var e = this._horizontal ? this.width : this.height, i = this._horizontal ? this.left : this.top, a = (e ? (t - i) / e : 0) * (this._offsets.left + 1 + this._offsets.left) - this._offsets.right, o = c(this._table, "pos", a, "time"); return n(o) }, getLabelWidth: function (t) { var e = this.options.ticks, i = this.ctx.measureText(t).width, n = o.toRadians(e.maxRotation), r = Math.cos(n), s = Math.sin(n); return i * r + o.valueOrDefault(e.fontSize, a.global.defaultFontSize) * s }, getLabelCapacity: function (t) { var e = this.options.time.displayFormats.millisecond, i = this.tickFormatFunction(n(t), 0, [], e), a = this.getLabelWidth(i), o = this.isHorizontal() ? this.width : this.height, r = Math.floor(o / a); return r > 0 ? r : 1 } }); t.scaleService.registerScaleType("time", e, { position: "bottom", distribution: "linear", bounds: "data", time: { parser: !1, format: !1, unit: !1, round: !1, displayFormat: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: { millisecond: "h:mm:ss.SSS a", second: "h:mm:ss a", minute: "h:mm a", hour: "hA", day: "MMM D", week: "ll", month: "MMM YYYY", quarter: "[Q]Q - YYYY", year: "YYYY" } }, ticks: { autoSkip: !1, source: "auto", major: { enabled: !1 } } }) } }, { 1: 1, 25: 25, 45: 45 }] }, {}, [7])(7) });